#! /bin/bash

#==========================================================
# Copyright @ 2013 Puppet Labs, LLC
# Redistribution prohibited.
# Address: 926 NW 13th Ave., Suite 210 / Portland, OR 97209
# Phone: (877) 575-9775
# Email: info@puppetlabs.com
#
# Please refer to the LICENSE.pdf file included
# with the Puppet Enterprise distribution
# for licensing information.
#==========================================================

#===[ Summary ]=========================================================

# This program installs Puppet Enterprise. Run this file to start the
# interactive installation or run with a "-h" option to display help.

#===[ Conventions ]=====================================================

# VARIABLES
#
# Variable names starting with "q_" are sanitized user answers to
# questions asked by the `ask` function.
#
# Variable names starting with "t_" are transient variables for use
# within a function. For example, "t_ask__name" is a transient variable
# for storing a "name" within the "ask" function. This convention is
# necessary because all POSIX sh variables are globals and there's no
# way to localize the scope of variables to prevent functions from
# stomping over each other's state.
#
# Variable names in all capital letters are globals that are
# intentionally shared between different functions.
#
# This file can be sourced into a shell for use as a library.

#===[ Global Varables ]================================================
CONSOLE_PORT_OPTIONS="443,3000,3001,3002,3003,3004,3005"

#===[ Functions ]=======================================================

# Enqueue vendor packages based on user's answers...
enqueue_vendor_packages() {
    # NONPORTABLE
    if [ "y" = "${q_puppet_cloud_install?}" -o "y" = "${q_database_install?}" ]; then
      case "${PLATFORM_NAME?}" in
        amazon | centos | rhel | sles)
          enqueue_package 'libxslt'
          ;;
        debian | ubuntu)
          enqueue_package 'libxslt1.1'
          ;;
      esac
    fi

    case "${PLATFORM_NAME?}" in
      amazon | centos | rhel)
        # pciutils and virt-what are required for facter
        enqueue_package 'pciutils'
        enqueue_package 'virt-what'

        enqueue_package 'system-logos'
        enqueue_package 'which'
        enqueue_package 'libxml2'
        # dmidecode is required for facter, but not available on el4
        case "${PLATFORM_RELEASE}" in
          6)
            enqueue_package 'dmidecode'
            enqueue_package 'cronie'
            ;;
          5)
            enqueue_package 'dmidecode'
            enqueue_package 'vixie-cron'
            ;;
        esac

        enqueue_package 'net-tools'
        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdb_install?}" ]; then
          enqueue_package 'libjpeg'
        fi

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
          enqueue_package 'apr'
          enqueue_package 'apr-util'
          enqueue_package 'curl'
          # JJM mailcap is required for /etc/mime.types
          # In both RHEL x5 and x6
          enqueue_package 'mailcap'
          if [ "x6" = "x${PLATFORM_RELEASE?}" ]; then
            # JJM apr-util-ldap is new in RHEL6
            enqueue_package 'apr-util-ldap'
          fi
        fi
        ;;
      sles)
        # pciutils and pmtools are required for facter
        # virt-what isn't packaged for sles, so we don't enqueue it for facter.
        enqueue_package 'pmtools'
        enqueue_package 'pciutils'
        enqueue_package 'cron'
        enqueue_package 'net-tools'
        enqueue_package 'libxml2'
        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdb_install?}" ]; then
          enqueue_package 'libjpeg'
        fi

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
          enqueue_package 'libapr1'
          enqueue_package 'curl'
          enqueue_package 'libapr-util1'
        fi
        ;;
      ubuntu | debian)
        # pciutils, dmidecode and virt-what are required for facter
        enqueue_package 'pciutils'
        enqueue_package 'dmidecode'
        enqueue_package 'virt-what'

        enqueue_package 'hostname'
        enqueue_package 'cron'
        enqueue_package 'libldap-2.4-2'
        enqueue_package 'libreadline5'
        enqueue_package 'libxml2'

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdb_install?}" ]; then
          enqueue_package 'libjpeg62'
        fi

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
          enqueue_package 'file'
          enqueue_package 'libmagic1'
          enqueue_package 'libpcre3'
          enqueue_package 'curl'
          enqueue_package 'perl'
          enqueue_package 'mime-support'
          enqueue_package 'libapr1'
          enqueue_package 'libcap2'
          enqueue_package 'libaprutil1'
          if [ ubuntu =  "${PLATFORM_NAME?}" ]; then
            enqueue_package 'libaprutil1-dbd-sqlite3'
            enqueue_package 'libaprutil1-ldap'
          elif [ debian = "${PLATFORM_NAME?}" ]; then
            enqueue_package 'libaprutil1-dbd-sqlite3'
            enqueue_package 'libaprutil1-ldap'
          fi
        fi
        ;;
      solaris)
        # JJM There are no vendor packages to install on Solaris
        :
        ;;
      aix)
        # No vendor packages
        :
        ;;
      *)
        display_failure "Do not know how to install vendor packages on this platform."
        ;;
    esac
}

# Install or upgrade all modules to /opt/puppet/share/puppet/modules
#
# Arguments: Whether it is an install or upgrade. Defaults to install
install_puppet_modules() {
    case "${1}" in
        upgrade)
            puppet_modules_to_install_file='upgrade_modules.txt'
            ;;
        install)
            puppet_modules_to_install_file='install_modules.txt'
            ;;
        wrapper)
            puppet_modules_to_install_file='wrapper_modules.txt'
            ;;
        cleanup)
            puppet_modules_to_install_file='upgrade_modules.txt'
            ;;
        *)
            puppet_modules_to_install_file='install_modules.txt'
            ;;
    esac
    # Save our current working directory.
    pushd "${INSTALLER_DIR}" &>/dev/null
    local t_install_dir="$(pwd)"
    t_module_target_dir="/opt/puppet/share/puppet/modules"
    if ! is_noop; then
        pushd ${t_module_target_dir} &>/dev/null
        t_module_backup_dir="${t_module_target_dir}/modules.upgrade.backup"
        # If upgrading or installing wrappers, ensure directory exists for backing up modules
        if [ -d "${t_module_target_dir?}" -a ! -d ${t_module_backup_dir} ] ; then
            run "mkdir -p ${t_module_backup_dir}"
        fi
        for module_pkg in $( cat "${t_install_dir?}/modules/${puppet_modules_to_install_file?}" );
        do
            if [ -e "${t_install_dir?}/modules/${module_pkg}"* ]; then
                cur_mod_pkg=`ls "${t_install_dir?}/modules/${module_pkg?}"*`
                # Old versions of puppet module installed into a vendor named directory
                # Slice off everything on the left up to and including the right most slash
                local module_file="${cur_mod_pkg##*/}"
                # Slice off everything on the right up to and including the version string
                local module_name_bad="${module_file%-*.*.*.tar.gz}"
                # Slice off the leading vendor name separated by a hyphen
                local module_name_good="${module_name_bad#*-}"
                # Back up module before overwriting
                back_up_module=y
                if [ -d "${module_name_bad}" ] ; then
                    module_to_back_up="${module_name_bad}"
                elif [ -d "${module_name_good}" ] ; then
                    module_to_back_up="${module_name_good}"
                else
                    back_up_module=n
                fi
                if [ y = "${back_up_module}" ] ; then
                    display "Backing up ${module_to_back_up} to ${module_to_back_up}.tar..."
                    run_suppress_output "tar cf ${module_to_back_up}.tar ${module_to_back_up}"
                    run_suppress_stdout "mv ${module_to_back_up}.tar ${t_module_backup_dir}/"
                    run_suppress_stdout "rm -rf ${module_to_back_up}"
                fi
                # Install module
                # --force is present to ensure we overwrite modules we control
                run_suppress_stdout '/opt/puppet/bin/puppet module install "'"${cur_mod_pkg}"'" --force --ignore-dependencies --modulepath /opt/puppet/share/puppet/modules'
                if [ -d "${module_name_bad}" ]; then
                    # Yes, these quotes are balanced and correct
                    run_suppress_stdout "mv '${module_name_bad}' '${module_name_good}'"
                fi
            fi
            # If there was a puppet-module symlink in ${PLATFORM_SYMLINK_TARGET}, remove it
            run_suppress_output "rm -f ${PLATFORM_SYMLINK_TARGET}/puppet-module"
        done

        # Back up and remove old modules if they exist (they're the same as wrapper module names)...
        if [ "${1}" = "cleanup" ]; then
            for module_pkg in $( cat "${t_install_dir?}/modules/wrapper_modules.txt" ); do
                module_to_back_up="${module_pkg#*-}"

                if [ -d "${module_to_back_up}" ]; then
                    display "Backing up ${module_to_back_up} to ${module_to_back_up}.tar..."
                    run_suppress_output "tar cf ${module_to_back_up}.tar ${module_to_back_up}"
                    run_suppress_stdout "mv ${module_to_back_up}.tar ${t_module_backup_dir}/"
                    run_suppress_stdout "rm -rf ${module_to_back_up}"
                fi
            done
        fi
        # Pop back to $INSTALLER_DIR
        popd &>/dev/null
    fi
    # Pop back to original $PWD
    popd &>/dev/null
    run_suppress_stdout "chown pe-puppet:pe-puppet -R ${t_module_target_dir?}"
}


# Configure mcollective on a puppet master
# This is a really weird way to do it, but as long
# as the module is installed correctly and the facts
# are defined correctly it will "just work"
configure_mcollective_master() {
    display "Generating mcollective password..."
    gen_password "/etc/puppetlabs/mcollective/credentials"
    run_suppress_stdout "chown ${PLATFORM_PUPPET_USER}:${PLATFORM_PUPPET_GROUP} /etc/puppetlabs/mcollective/credentials"
    run_suppress_stdout "chmod 600 /etc/puppetlabs/mcollective/credentials"
    display "Running puppet apply to configure MCollective ..."
    t_mcollective_roles="pe_mcollective::role::master,pe_mcollective::role::agent"
    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        t_mcollective_roles="${t_mcollective_roles},pe_mcollective::role::console"
    fi
    run_suppress_stdout "/opt/puppet/bin/puppet apply --no-report --modulepath /opt/puppet/share/puppet/modules -v --exec 'include ${t_mcollective_roles?}'"
    display "MCollective configuration is complete ..."
}

# Configure auth.conf for certificate manager on the master
# This will also be in the default group, but this ensures it is ready after install
configure_certificate_manager() {
    display "Setting up auth.conf..."
    run_suppress_stdout "/opt/puppet/bin/puppet apply --no-report --modulepath /opt/puppet/share/puppet/modules -v --exec 'class { request_manager: }'"
    display "auth.conf updated."
}

configure_postgresql_server() {
    display "Configuring postgresql server..."
    run "mkdir -p /opt/puppet/var/lib/pgsql/9.2"
    run_suppress_stdout "/opt/puppet/bin/puppet apply --no-report --modulepath /opt/puppet/share/puppet/modules -v --exec \"class { pe_postgresql: version => '9.2', config_hash => { listen_addresses => '${q_database_host?}', ip_mask_allow_all_users => '0.0.0.0/0' } }\""
    display "PostgreSQL server configured."
    pgs_configured="true"
}

configure_puppetdb() {
    display "Configuring puppetdb..."
    if [ y = "${q_puppetdb_install?}" ]; then
        enqueue_package 'pe-puppetdb'
    fi
    if [ y = "${q_puppetmaster_install?}" ]; then
        enqueue_package 'pe-puppetdb-terminus'
    fi
    install_queued_packages

    #Add required paths so that psql would be launchable by the module
    if [ y = "${q_puppetdb_install?}" ]; then
        # XXX Classify this parameter in the console, when console is remote (use hostname).
        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppetdb.pp.erb' | PATH=/opt/puppet/bin:$PATH LD_LIBRARY_PATH=/opt/puppet/lib puppet apply --no-report --modulepath=/opt/puppet/share/puppet/modules"
    fi
    # We need to configure the master to talk to PuppetDB.
    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # XXX Classify these parameters in the console!
        run_suppress_stdout "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppetdb_master.pp.erb' | /opt/puppet/bin/puppet apply --no-report --modulepath=/opt/puppet/share/puppet/modules --certname=${q_puppetmaster_certname?}"
    fi

    if [ n = "${q_puppetmaster_install?}" -a y = ${q_puppetdb_install?} ]; then
      #Run puppet agent once more, this time without the --no-op option since the pe-puppetdb package is already present
      run_suppress_stdout "/opt/puppet/bin/puppet agent --test --color=false || true"
    fi

    display "PuppetDB configured."
}

configure_puppetdb_classes() {
    display "Configuring classes and groups for PuppetDB node..."

    add_console_node ${q_puppetdb_hostname?}

    add_console_group "puppet_puppetdb"
    add_console_group_to_node ${q_puppetdb_hostname?} "puppet_puppetdb"

    add_console_class "pe_puppetdb"
    add_console_class_to_node ${q_puppetdb_hostname?} "pe_puppetdb"

    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "ssl_listen_address" "${q_puppetdb_hostname?}"
    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "ssl_listen_port" "${q_puppetdb_port?}"
    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "database_host" "${q_database_host?}"
    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "database_port" "${q_database_port?}"
    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "database_name" "${q_puppetdb_database_name?}"
    add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "database_username" "${q_puppetdb_database_user?}"

    if [ 'y' = "${q_pe_database}" ]; then
        add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "manage_database" "true"
    else
        add_console_classparam_to_node ${q_puppetdb_hostname?} "pe_puppetdb" "manage_database" "false"
    fi

    display "Configuration of classes and groups for PuppetDB node was enqueued..."
}

configure_puppetdb_master_classes() {
    display "Configuring classes and groups for PuppetDB master node..."

    add_console_node ${q_puppetagent_server?}

    add_console_group "puppet_master"
    add_console_group_to_node ${q_puppetagent_server?} "puppet_master"

    add_console_class "pe_puppetdb::master"
    add_console_class_to_node ${q_puppetagent_server?} "pe_puppetdb::master"

    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "puppetdb_server" "${q_puppetdb_hostname?}"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "puppetdb_port" "${q_puppetdb_port?}"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "manage_config" "true"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "manage_routes" "true"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "manage_storeconfigs" "true"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "manage_report_processor" "true"
    add_console_classparam_to_node ${q_puppetagent_server?} "pe_puppetdb::master" "enable_reports" "true"

    display "Configuration of classes and groups for PuppetDB master node was enqueued..."
}

# High level function classifies both the console and master with the appropriate subclasses of the pe_mcollective module
# so that they can be set up correctly.
classify_mcollective_roles() {
    display "Configuring nodes, classes and groups for mcollective..."
    master_node=${q_puppetagent_server?}
    console_node=${q_puppetagent_certname?}

    # Create console and master classes, group, add classes to groups.
    for role in master console; do
        t_cur_node="${role}_node"
        add_console_class "pe_mcollective::role::${role}"
        add_console_group "puppet_${role}"
        add_console_class_to_group "pe_mcollective::role::${role}" "puppet_${role}"
        add_console_node ${!t_cur_node}
        add_console_group_to_node ${!t_cur_node} "puppet_${role}"
    done

    display "Configuration of nodes, classes and groups for mcollective was enqueued..."
}

# Simple listing of cloud gems that get enqueued
# on many platforms (EL5, EL6, SLES11, lenny, lucid, squeeze)
#
handle_cloud() {
    enqueue_package 'pe-cloud-provisioner'
    enqueue_package 'pe-rubygem-guid'
    enqueue_package 'pe-rubygem-fog'
    enqueue_package 'pe-rubygem-builder'
    enqueue_package 'pe-rubygem-excon'
    enqueue_package 'pe-rubygem-formatador'
    enqueue_package 'pe-rubygem-mime-types'
    enqueue_package 'pe-rubygem-multi-json'
    enqueue_package 'pe-rubygem-net-scp'
    # This is now being enqueued for all el, sles, deb and ubuntu installs so is no longer needed here.
    # enqueue_package 'pe-rubygem-net-ssh'
    enqueue_package 'pe-rubygem-nokogiri'
    enqueue_package 'pe-rubygem-ruby-hmac'
    enqueue_package 'pe-rubygem-trollop'
    enqueue_package 'pe-rubygem-rbvmomi'
}

enqueue_agent_packages() {
    case "${PLATFORM_NAME?}" in
        amazon | centos | rhel | sles | ubuntu | debian)
            enqueue_package 'pe-puppet-enterprise-release'
            enqueue_package 'pe-libyaml'
            enqueue_package 'pe-ruby'
            enqueue_package 'pe-ruby-shadow'
            enqueue_package 'pe-ruby-stomp'
            enqueue_package 'pe-mcollective-common'
            enqueue_package 'pe-mcollective'
            enqueue_package 'pe-facter'
            enqueue_package 'pe-puppet'
            enqueue_package 'pe-augeas'
            enqueue_package 'pe-ruby-augeas'
            enqueue_package 'pe-ruby-ldap'
            enqueue_package 'pe-hiera'
            enqueue_package 'pe-ruby-rgen'
            enqueue_package 'pe-rubygem-net-ssh'
            enqueue_package 'pe-rubygem-deep-merge'
            ;;

        aix)
            enqueue_package 'pe-puppet-enterprise-release'
            enqueue_package 'pe-augeas'
            enqueue_package 'pe-libyaml'
            enqueue_package 'pe-ruby'
            enqueue_package 'pe-ruby-augeas'
            enqueue_package 'pe-ruby-stomp'
            enqueue_package 'pe-ruby-rgen'
            enqueue_package 'pe-rubygem-deep-merge'
            enqueue_package 'pe-hiera'
            enqueue_package 'pe-facter'
            enqueue_package 'pe-mcollective'
            enqueue_package 'pe-mcollective-common'
            enqueue_package 'pe-puppet'
            ;;

        solaris)
            enqueue_package 'PUPpuppet-enterprise-release'
            enqueue_package 'PUPlibyaml'
            enqueue_package 'PUPruby'
            enqueue_package 'PUPopenssl'
            enqueue_package 'PUPstomp'
            enqueue_package 'PUPmcollective'
            enqueue_package 'PUPfacter'
            enqueue_package 'PUPpuppet'
            enqueue_package 'PUPhiera'
            enqueue_package 'PUPruby-augeas'
            enqueue_package 'PUPaugeas'
            enqueue_package 'PUPruby-rgen'
            enqueue_package 'PUPdeep-merge'
            ;;
        *)
            display_failure "Do not know how to install Ruby or Puppet on this platform"
            ;;
    esac
}

query_about_master_connectivity() {
    t_qamc__msg="Puppet Master at '${q_puppetagent_server}:8140' could not be reached."

    # fail if the answer file tells us to
    if [ 'y' == "${q_fail_on_unsuccessful_master_lookup}" ]; then
        display_failure "${t_qamc__msg} Aborting installation as directed by answer file. Set 'q_fail_on_unsuccessful_master_lookup' to 'n' if installation should continue despite communication failures."
    elif [ 'n' == "${q_fail_on_unsuccessful_master_lookup}" -a 'y' == "${IS_ANSWER_REQUIRED}" ]; then
        break
    fi

    ask q_continue_or_reenter_master_hostname "The installer couldn’t reach the puppet master server at ${q_puppetagent_server}. If this server name is correct, please check your DNS configuration to ensure the puppet master node can be reached by name, and make sure your firewall settings allow traffic on port 8140. Enter ‘r’ if you need to re-enter the puppet master’s name; otherwise, enter ‘c’ to continue." cr
    if [ 'c' == "${q_continue_or_reenter_master_hostname}" ]; then
        break
    else
        unset q_puppetagent_server
        ask q_puppetagent_server "Puppet master hostname to connect to?" String 'puppet'
    fi
    unset q_continue_or_reenter_master_hostname
}

# Generate global Passenger configuration
generate_global_passenger_conf() {
    pool_size=$(get_passenger_pool_size)
    let max_per_app=($pool_size/2)

    #...[ passenger-extra.conf ]............................................

    filebuffer_clear
    filebuffer_append \
"PassengerHighPerformance on
PassengerMaxRequests 40
PassengerPoolIdleTime 15
PassengerMaxPoolSize ${pool_size}"
    if [ y = "${q_puppetmaster_install?}" -a y = "${q_puppet_enterpriseconsole_install?}" ]; then
        filebuffer_append "PassengerMaxInstancesPerApp ${max_per_app}"
    fi
    filebuffer_write "/etc/puppetlabs/httpd/conf.d/passenger-extra.conf"
}

cron_enable() {
    case "${PLATFORM_NAME?}" in
        amazon | centos | rhel )
            enable_service 'crond'
            bounce_service 'crond'
            ;;
        debian | ubuntu | sles)
            enable_service 'cron'
            bounce_service 'cron'
            ;;
        solaris)
            run_suppress_stdout "/usr/sbin/svcadm enable svc:/system/cron:default"
            ;;
        aix)
            if ! /usr/sbin/lsitab "cron" > /dev/null; then
                run_suppress_stdout '/usr/sbin/mkitab "cron:23456789:respawn:/usr/sbin/cron"'
            fi
            ;;
    esac
}

# Utility function to re-query the user regarding an unavailable
# value for a database variable, e.g. a db name that is in use already
# Ask twice, then fail.
# Arguments:
# 1. The value of the resource to check for, e.g. console_auth
# 2. A string, one of either "user" or "db" to flag *which* kind of resource to check
# 3. The variable that the value should be assigned to
# 4. An optional message string to display to the user in the ask message
# 5. An optional failure message to display
requery_db_resource_value() {
    t_success="n"
    t_count=0
    t_value="${1?}"
    t_type="${2?}"
    t_variable="${3?}"
    t_message="${4}"
    t_fail_message="${5}"
    while [ "n" = "${t_success}" ] && [ ${t_count} -lt 2 ] ; do
        unset "${t_variable}"
        if [ -z "${t_message}" ] ; then
            ask ${t_variable} "The ${t_type} name (${t_value}) for this host already exists on the PostgreSQL server. Please enter an unused ${t_type} name?" String
        else
            ask ${t_variable} "${t_message}" String
        fi
        eval t_value="${!t_variable}"
        if is_db_name_available "${t_value}" "${t_type}" ; then
            t_success="y"
        fi
        t_count=$(($t_count + 1))
    done
    if [ "n" = "${t_success}" ] ; then
        # We tried twice, and failed. Fail hard.
        if [ -z "${t_fail_message}" ] ; then
            display_failure "Unable to create the ${t_type} with the name ${t_value}, ${t_type} already exists on the PostgreSQL server."
        else
            display_failure "${t_fail_message}"
        fi
    fi
}

# Wait for the database server to be up and running. This is used so that we
# don't try to verify the database until the server is ready to accept
# connections. This is only done on database installs. $1 is the number of
# connection attempts to make. Returns 0 if the database is running, and 1 if
# the maximum number of attempts is reached.
wait_for_db() {
    t_wait_for_db_max_retries="${1?}"
    t_wait_for_db_tries=0

    [ y = "${q_database_install?}" ] || return 0;

    while [ "${t_wait_for_db_tries?}" -lt "${t_wait_for_db_max_retries?}" ]; do
        if eval "su - ${q_database_root_user} -c \"${t_path_to_psql?} --command='\l'\" -s /bin/bash" &> /dev/null; then
            return 0
        else
            sleep 0.5
            t_wait_for_db_tries=$(expr "${t_wait_for_db_tries?}" + 1)
        fi
    done

    return 1
}

# Verify a single database on the database server.
# The arguments to this function are the database, username, and password to
# verify.
verify_single_database() {
    t_verify_database="${1?}"
    t_verify_user="${2?}"
    t_verify_password="${3?}"

    create_db_encoding="ENCODING 'utf8' LC_CTYPE 'en_US.utf8' LC_COLLATE 'en_US.utf8' template template0"
    t_psql_remote_string="--host='${q_database_host?}' --port=${q_database_port?}"

    t_db_setup=0

    if ! output=$(run "PGPASSWORD='${t_verify_password?}' ${t_path_to_psql?} --username='${t_verify_user?}' ${t_psql_remote_string} --dbname='${t_verify_database?}' --command='\dT' 2>&1"); then
        if echo $output | egrep -q "role \"${t_verify_user?}\" does not exist" ; then
            echo "Could not connect to the postgresql server using the user: ${t_verify_user?}. Please log in as a privileged user and set it up manually. Example SQL commands:" | display_wrapped_text
            display_newline
            printf -- '%s' "
            CREATE USER \"${t_verify_user}\" PASSWORD '${t_verify_password?}';
            "
        elif echo $output | egrep -q "database \"${t_verify_database?}\" does not exist" ; then
            echo "Could not connect to postgresql server using database: ${t_verify_database?} with user: ${t_verify_user?}. Please log in as a privileged user and set it up manually. Example SQL commands:" | display_wrapped_text
            display_newline
            printf -- '%s' "
            CREATE DATABASE \"${t_verify_database}\" OWNER \"${t_verify_user}\" ${create_db_encoding?};
            "
        else
            echo "Could not connect to postgres server using the user: ${t_verify_user?} and database: ${t_verify_database?}. Please log in as a privileged user and set up the user or database manually. Example SQL commands:" | display_wrapped_text
            display_newline
            printf -- '%s' "
            CREATE USER \"${t_verify_user}\" PASSWORD '${t_verify_password?}';
            CREATE DATABASE \"${t_verify_database}\" OWNER \"${t_verify_user}\" ${create_db_encoding?};
            "
        fi
        display_newline

        t_db_setup=1
    fi
}

# verify_postgresql: there are two basic cases
# 1) we are verifying a root user
# 2) we are verifying existing credentials and databases
#
# The first and only argument represents which databases to verify: console,
# puppetdb or all.
#
# The function uses several installer variables including:
# - q_database_install
# - q_database_host
# - q_database_port
# - q_database_root_user
# - q_puppet_enterpriseconsole_database_name
# - q_puppet_enterpriseconsole_database_user
# - q_puppet_enterpriseconsole_database_password
# - q_puppet_enterpriseconsole_auth_database_name
# - q_puppet_enterpriseconsole_auth_database_user
# - q_puppet_enterpriseconsole_auth_database_password
# - q_puppetdb_database_name
# - q_puppetdb_database_user
# - q_puppetdb_database_password
# - t_path_to_psql
#
# It returns 0 for success if the databases/users exist or the root account is valid
# and non-zero for failure if those databases/users don't exist or the root account is invalid

verify_postgresql() {
    t_db_setup=0

    # If we are doing the setup, we need to verify that the root account credentials are good.
    if [ y = "${q_database_install?}" ]; then
        if ! eval "su - ${q_database_root_user} -c \"${t_path_to_psql?} --command='\l'\" -s /bin/bash" &> /dev/null; then
            display_failure "Could not connect to the postgresql server using the ${q_database_root_user} user."
        fi
    elif !(is_upgrade && is_PE_x_or_greater '3'); then
        # If we aren't doing the setup, we need to verify that the console and PuppetDB account credentials are good and the databases exist.
        # We check each in turn and give example SQL commands for each block upon failure. We don't fail hard on error until the function returns,
        # so all five blocks can display errors to the user.

        # First we check that the console user exists and that we can connect to the console database using the console user credentials.
        if [ 'all' = ${1?} -o 'console' = ${1?} ]; then
            if ! verify_single_database "${q_puppet_enterpriseconsole_database_name?}" "${q_puppet_enterpriseconsole_database_user?}" "${q_puppet_enterpriseconsole_database_password?}"; then
                t_db_setup=1
            fi

            if ! verify_single_database "${q_puppet_enterpriseconsole_auth_database_name?}" "${q_puppet_enterpriseconsole_auth_database_user?}" "${q_puppet_enterpriseconsole_auth_database_password?}"; then
                t_db_setup=1
            fi
        fi

        if [ 'all' = "${1?}" -o 'puppetdb' = "${1?}" ]; then
            if ! verify_single_database "${q_puppetdb_database_name?}" "${q_puppetdb_database_user?}" "${q_puppetdb_database_password?}"; then
                t_db_setup=1
            fi
        fi
    fi

    return ${t_db_setup?}
}

# Verify the db credentials, as well as the console db if we're installing the
# console.
verify_db() {
    display_comment "Verifying postgresql credentials..."
    if [ y = "${q_puppetdb_install?}" ]; then
        if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            t_verify_dbs='all'
        else
            t_verify_dbs='puppetdb'
        fi
    elif [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        t_verify_dbs='console'
    fi

    if ! verify_postgresql "${t_verify_dbs?}"; then
        display_failure "The provided postgresql credentials could not be verified. Please follow the above instructions and try again."
    fi
}

# Warn about needed open ports
warn_open_ports() {
    t_inbound_port_string=""
    t_outbound_port_string=""

    # Add 443 for HTTPS connections if the console is being installed...
    # ... inbound if it's a console install...
    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
      t_inbound_port_string="${t_inbound_port_string?}${q_puppet_enterpriseconsole_httpd_port?}, "
    fi
    # ... outbound if it's a puppetmaster install and not a standalone install
    if [ y = "${q_puppetmaster_install?}" -a ! y = "${q_all_in_one_install?}" ]; then
      t_outbound_port_string="${t_outbound_port_string?}${q_puppetmaster_enterpriseconsole_port?}, "
    fi

    # Add 8140 for the puppetmaster and 61613 for mcollective/stomp/activemq...
    # ... inbound if it's a master install...
    if [ y = "${q_puppetmaster_install?}" ]; then
      t_inbound_port_string="${t_inbound_port_string?}8140, 61613, "
    else
      # ... otherwise outbound
      t_outbound_port_string="${t_outbound_port_string?}8140, 61613, "
    fi

    # Add 5432 for Postgres...
    # ... inbound if it's a non-console database install...
    if [ y = "${q_database_install?}" -a ! y = "${q_puppet_enterpriseconsole_install?}" ]; then
      t_inbound_port_string="${t_inbound_port_string?}${q_database_port?}, "
    fi
    # ... outbound on a non-database PuppetDB or console install
    if [ ! y = "${q_database_install?}" ] && [ y = "${q_puppetdb_install}" -o y = "${q_puppet_enterpriseconsole_install}" ]; then
      t_outbound_port_string="${t_outbound_port_string?}${q_database_port?}, "
    fi

    # Add 8081 for PuppetDB if not a standalone install...
    if [ ! y = "${q_all_in_one_install?}" ]; then
      # ... inbound if it's a PuppetDB install
      if [ y = "${q_puppetdb_install?}" ]; then
        t_inbound_port_string="${t_inbound_port_string?}${q_puppetdb_port?}, "
      fi
      # ... outbound if it's a puppetmaster or console install
      if [ y = "${q_puppetmaster_install}" ]; then
        t_outbound_port_string="${t_outbound_port_string?}${q_puppetdb_port?}, "
      fi
    fi

    if [ -n "${t_inbound_port_string?}" ]; then
        echo "If you have a firewall running, please ensure the following TCP ports are open: ${t_inbound_port_string%, }" | display_wrapped_text
        display_newline
    fi

    if [ -n "${t_outbound_port_string?}" ]; then
        echo "If you have a firewall running, please ensure outbound connections to are allowed via the following TCP ports: ${t_outbound_port_string%, }" | display_wrapped_text
        display_newline
    fi

}

display_puppetdb_memory_guidelines() {
    display "Use this guideline to determine the amount of memory required for the number of nodes installed."
    display_newline
    display " NODES       | MEMORY"
    display "------------------------------"
    display " 1    -  100 | 192 -  512 MB"
    display " 100  -  500 | 512 - 1024 MB"
    display " 500  - 1000 | 1   -    2 GB"
    display " 1000 - 2000 | 2   -    4 GB"
    display "      > 2000 | 4 GB or greater"
    display_newline
}

# Warn if this is a puppetmaster install and the memory size is below the
# minimum or recommend amount.
warn_on_low_memory() {
    if [ y = "${q_puppetmaster_install?}"  -o y = "${q_puppetdb_install}" ]; then
        problem='n'
        if ( ! is_noop); then
            memorysize_mb=$(/opt/puppet/bin/facter memorysize_mb | cut -d'.' -f1)

            if [ y = "${q_puppetmaster_install?}" ]; then
                if [ $memorysize_mb -lt 1024 ]; then
                    echo "WARNING: This system has ${memorysize_mb} MB of memory, which is below the minimum requirement of 1 GB for the puppet master role.  You can attempt to use this system as a puppet master, but will probably experience serious problems unless you increase its memory." | display_wrapped_text
                    display_newline
                    problem='y'
                elif [ $memorysize_mb -lt 4096 ]; then
                    echo "NOTICE: This system has ${memorysize_mb} MB of memory, which is below the 4 GB we recommend for the puppet master role.  Although this node will be a fully functional puppet master, you may experience poor performance with large numbers of nodes.  You can improve the puppet master's performance by increasing its memory." | display_wrapped_text
                    display_newline
                    problem='y'
                fi
            fi

            if [ y = "${q_puppetdb_install}" ]; then
                if [ $memorysize_mb -lt 192 ]; then
                    echo "WARNING: This system has ${memorysize_mb} MB of memory, which is below the minimum requirement of 192 MB for the PuppetDB role.  You can attempt to use this system as a PuppetDB, but will probably experience serious problems unless you increase its memory." | display_wrapped_text
                    display_newline
                    display_puppetdb_memory_guidelines
                    problem='y'
                elif [ $memorysize_mb -lt 4096 ]; then
                    echo "NOTICE: This system has ${memorysize_mb} MB of memory, which is below the 4 GB we recommend for the PuppetDB role.  Although this node will be a fully functional PuppetDB, you may experience poor performance with large numbers of nodes.  You can improve PuppetDB's performance by increasing its memory." | display_wrapped_text
                    display_newline
                    display_puppetdb_memory_guidelines
                    problem='y'
                fi
            fi

            if [ y = "${problem?}" ]; then
                display_newline
                display_major_separator
            fi
        fi
    fi
}

#===[ Main ]============================================================

. "$(dirname "${0?}")/utilities"

# Version variables to use when creating links and printing messages.
PE_VERSION=$(cat "$(dirname "${0?}")/VERSION" 2> /dev/null)
PE_LINK_VER=$(echo ${PE_VERSION?} | cut -d '.' -f1,2)

if [ "puppet-enterprise-installer" = "$(basename "${0?}")" ]; then

    #---[ Environment ]-----------------------------------------------------

    # Installing via sudo may not add required path components
    PATH=$PATH:/usr/sbin:/usr/bin:/sbin:/bin

    #---[ Paranoia ]--------------------------------------------------------

    # Exit immediately if a simple command exits with a non-zero status:
    set -e

    #---[ Prepare ]---------------------------------------------------------

    # Catch CTRL-C and "set -e" errors:
    register_exception_handler

    # Setup "PLATFORM_*" variables:
    prepare_platform

    #---[ Process command-line options ]------------------------------------

    ANSWER_FILE_TO_LOAD=
    ANSWER_FILE_TO_SAVE=
    IS_ANSWER_REQUIRED=n
    LOGFILE=
    IS_NOOP=n
    IS_DEBUG=n
    IS_VERBOSE_DEBUG=n
    IS_SAVE_ANSWERS=n
    IS_SUPPRESS_OUTPUT=n
    IS_UPGRADE=n

    while getopts a:A:Dhl:nqs:V name; do
        case "$name" in
            a)
                ANSWER_FILE_TO_LOAD="${OPTARG?}"
                IS_ANSWER_REQUIRED=y
                ;;
            A)
                ANSWER_FILE_TO_LOAD="${OPTARG?}"
                IS_ANSWER_REQUIRED=n
                ;;
            D)
                IS_DEBUG=y
                ;;
            h)
                display_header
                display_usage
                ;;
            l)
                LOGFILE="${OPTARG?}"
                ;;
            n)
                IS_NOOP=y
                ;;
            q)
                IS_SUPPRESS_OUTPUT=y
                ;;
            s)
                ANSWER_FILE_TO_SAVE="${OPTARG?}"
                IS_SAVE_ANSWERS=y
                ;;
            V)
                IS_VERBOSE_DEBUG=y
                ;;
            ?)
                display_header
                display_usage "Illegal option specified"
                ;;
        esac
    done

    #---[ Announce installation ]-------------------------------------------

     # Enforce quiet mode if specified
     if is_quiet ; then
       run_quiet_mode
     fi

    # Enforce very verbose debugging if specified
    is_verbose_debug

    # Announce installer:
    display_header

    # Set umask to 0022. This is in a subshell and inside a conditional, so this umask will only
    # persist for the run of the installer.
    umask 0022

    # Prepare the installer variable:
    installer_dir > /dev/null

    [ -s $(installer_dir)/VERSION ] || display_failure "The VERSION file seems to be missing from your installer. The installer cannot proceed without it."

    # Check if we are on a supported platform
    if [ ${IS_SAVE_ANSWERS} != y ]; then
      platform_support_check
    fi

    # Check user:
    prepare_user

    # Load answers if specified:
    if [ ! -z "${ANSWER_FILE_TO_LOAD?}" ]; then
        load_answers "${ANSWER_FILE_TO_LOAD?}"

        # Backward compatibility with answers from PE <= 1.2.x
        convert_answers
    fi

    # Prepare log file:
    if ( ! is_save_answers ) && ( ! is_noop ) ; then
        prepare_log_file
    fi

    # PE-537 without libgcc_s.so.1, our compiled software will not run.
    if [ "${PLATFORM_NAME}" = "solaris" ] && ( ! is_package_installed "SUNWgccruntime" ); then
        display_failure "SUNWgccruntime provides /usr/sfw/lib/libgcc_s.so.1, which is required for Puppet Enterprise, please install the package from your Solaris installation media and run ${0} again."
    fi

    # Check if we are working on a system that already has an install
    if [ -x /opt/puppet/bin/puppet ]; then
        IS_UPGRADE=y

        CURRENT_PE_VERSION=$(/opt/puppet/bin/puppet --version | cut -d' ' -f4 | cut -d')' -f1 | cut -d'r' -f1)
        CURRENT_PE_MAJOR=$(echo $CURRENT_PE_VERSION | cut -d'.' -f1)

        display_newline
        display " === Upgrade from version ${CURRENT_PE_VERSION?} detected === "
        display_newline
        #if ( is_package_installed 'pe-puppet-server' || is_package_installed 'pe-puppet-master' || is_package_installed 'pe-puppet-dashboard' || is_package_installed 'pe-puppetdb' ); then
        #    display_failure "Upgrades are only supported on agents"
        #fi
        q_puppetagent_install=y

        if is_cloud_provisioner; then
            q_puppet_cloud_install='y'
        else
            q_puppet_cloud_install='n'
        fi
        # If they wanted the symlinks, then they installed them already in a previous install
        q_puppet_symlinks_install='n'

        if is_puppetmaster; then
            q_puppetmaster_install='y'
            q_puppetmaster_certname="$(/opt/puppet/bin/puppet master --configprint certname)"
            # TODO Read this from the puppetmaster.conf
            q_puppetmaster_dnsaltnames=${q_puppetmaster_dnsaltnames:-"$(/opt/puppet/bin/puppet master --configprint dns_alt_names)"}
            #q_puppetca_install='y'

            extract_console_location_from_enc_script
        else
            q_puppetmaster_install='n'
            #q_puppetca_install='n'
        fi

        if is_console; then
            q_puppet_enterpriseconsole_install='y'
            q_puppet_enterpriseconsole_httpd_port="${q_puppet_enterpriseconsole_httpd_port:-"$(${PLATFORM_EGREP} Listen /etc/puppetlabs/httpd/conf.d/puppetdashboard.conf | sed -e 's/^\s*Listen [^:]*:\([[:digit:]]*\)\s*$/\1/')"}"

            # We transfer by default, but the user can override with an answer file.
            if [ "${CURRENT_PE_MAJOR?}" -eq "2" ]; then
                : ${q_database_transfer:='y'}
            else
                q_database_transfer='n'
            fi

            if [ -z "${q_puppet_enterpriseconsole_httpd_port}" ]; then
                display_failure "Could not determine the existing Puppet Enterprise console port"
            fi

            if [ y = "${q_database_transfer?}" ]; then
                display_comment "In order to migrate your console data from MySQL to PostgreSQL, a database export and import will be performed. The export utility requires a secure, writeable intermediate staging directory with sufficient free space to store the database export."
                ask q_database_export_dir "What is a staging directory for use by the export utility?" String
            fi
        else
            q_puppet_enterpriseconsole_install='n'
        fi

        if is_puppetdb; then
            q_puppetdb_install='y'

            # If it's not installed, we have to ask if they want to move to
            # pe-postgres, so we can't just set this to no.
            if is_postgres; then
                q_database_install='y'
            fi

            q_puppetdb_hostname="${q_puppetdb_hostname:-"$(get_ini_field '/etc/puppetlabs/puppetdb/conf.d/jetty.ini' 'ssl-host')"}"
            q_puppetdb_port="${q_puppetdb_port:-"$(get_ini_field '/etc/puppetlabs/puppetdb/conf.d/jetty.ini' 'ssl-port')"}"

            t_main_database_subname="$(get_ini_field '/etc/puppetlabs/puppetdb/conf.d/database.ini' 'subname')"
            q_database_host="${q_database_host:-$(echo "${t_main_database_subname?}" | sed -e 's/\/\/\([^:][^:]*\):\([0-9][0-9]*\)\/\(\S*\)/\1/')}"
            q_database_port="${q_database_port:-$(echo "${t_main_database_subname?}" | sed -e 's/\/\/\([^:][^:]*\):\([0-9][0-9]*\)\/\(\S*\)/\2/')}"
            q_puppetdb_database_name="${q_puppetdb_database_name:-$(echo "${t_main_database_subname?}" | sed -e 's/\/\/\([^:][^:]*\):\([0-9][0-9]*\)\/\(\S*\)/\3/')}"

            q_puppetdb_database_user="${q_puppetdb_database_user:-$(get_ini_field '/etc/puppetlabs/puppetdb/conf.d/database.ini' 'username')}"
            q_puppetdb_database_password="${q_puppetdb_database_password:-$(get_ini_field '/etc/puppetlabs/puppetdb/conf.d/database.ini' 'password')}"
        else
            # This could be changed later during the all-in-one check.
            q_puppetdb_install='n'

            if is_puppetmaster; then
                # Try to figure out where PuppetDB is from the puppetdb.conf file
                if is_package_installed 'pe-puppetdb-terminus' && [ -e '/etc/puppetlabs/puppet/puppetdb.conf' ]; then
                    q_puppetdb_hostname=${q_puppetdb_hostname:-"$(get_ini_field '/etc/puppetlabs/puppet/puppetdb.conf' server)"}
                    q_puppetdb_port=${q_puppetdb_port:-"$(get_ini_field '/etc/puppetlabs/puppet/puppetdb.conf' port)"}
                fi
            fi
        fi

        # If we're a master and a console, we must be either a 2.x install (in
        # which case we get converted to all-in-one), or a 3.x all-in-one
        # install (which means we must already have puppetdb and the database).
        if is_puppetmaster && is_console; then
            q_all_in_one_install='y'

            q_puppetdb_install='y'
        else
            q_all_in_one_install='n'
        fi

        q_puppetagent_certname="$(/opt/puppet/bin/puppet agent --configprint certname)"
        q_puppetagent_server="$(/opt/puppet/bin/puppet agent --configprint server)"

        display_comment "Stopping Puppet Enterprise services for upgrade"

        if is_puppetmaster || is_console; then
            run_suppress_stdout "/opt/puppet/bin/puppet resource service pe-httpd ensure=stopped"
        fi
        if is_puppetdb; then
            run_suppress_stdout "/opt/puppet/bin/puppet resource service pe-puppetdb ensure=stopped"
        fi
    fi

    #---[ Support for installing in a symlinked opt dir ]--------------------

    if [ -L "/opt" ]; then
        case "${PLATFORM_NAME?}" in
            solaris)
                declare -x PKG_NONABI_SYMLINKS='true'
                ;;
        esac
    fi

    #---[ Interview user ]--------------------------------------------------

    display_step 'SELECT AND CONFIGURE ROLES' n
    display_newline

    if [ 'false' =  "${CLIENT_ONLY?}" ]; then
        echo "This installer lets you select and install the various roles required in a Puppet Enterprise deployment: puppet master, console, database, cloud provisioner, and puppet agent." | display_wrapped_text
        display_newline
        display_newline

        display "NOTE: when specifying hostnames during installation, use the fully-qualified domain name (foo.example.com) rather than a shortened name (foo)."
        display_newline

        display_product 'puppet master' "The puppet master serves configurations to a group of puppet agent nodes. This role also provides MCollective's message queue and client interface. It should be installed on a robust, dedicated server."
        ask q_puppetmaster_install 'Install puppet master?' yN

        if [ y = "${q_puppetmaster_install?}" ]; then
            display_product "standalone install" "You may choose to either install PuppetDB and the console on this node, or to install each service on its own node. If you choose not to install PuppetDB and the console on this node, you will be asked where to find them."
            ask q_all_in_one_install "Install PuppetDB and console on this node?" Yn

            # If all-in-one, then autoselect everything. If not all-in-one,
            # then deselect everything.
            if [ y = "${q_all_in_one_install?}" ]; then
                q_puppetdb_install='y'
                q_puppet_enterpriseconsole_install='y'
            else
                q_puppetdb_install='n'
                q_puppet_enterpriseconsole_install='n'
            fi
        else
            q_all_in_one_install=n

            ask q_puppetagent_server "Puppet master hostname to connect to?" String puppet
            if ( ! is_save_answers ) && [ 'n' = "${q_skip_master_verification:-"n"}" ] ; then
                while ! tcp_port_in_use "${q_puppetagent_server}" 8140 ; do
                    query_about_master_connectivity
                done
            fi
            :           ${q_fail_on_unsuccessful_master_lookup:='y'}
        fi

        # If you're *not* installing a master, you can choose PuppetDB
        if [ ! y = "${q_puppetmaster_install?}" ]; then
            display_product 'database support' "This role provides database support for PuppetDB and the console. PuppetDB is the fast, scalable, and reliable centralized data service for Puppet. It caches data generated by Puppet, and gives you advanced features at awesome speed with a powerful API. The console uses data provided by a PostgreSQL server and database both of which will be installed along with PuppetDB on the node you specify. You can install database support on the same node as the console or on a separate node."

            echo "IMPORTANT: If you choose not to install PuppetDB on at this time, you will be prompted for the host name of the node you intend to use to provide database services. Note that you must install database support on that node for the console to function. When using a separate node, you should install database support on it BEFORE installing the console role." | display_wrapped_text
            display_newline
            display_newline

            ask q_puppetdb_install 'Install PuppetDB?' yN

            # If you've chosen PuppetDB, you cannot choose console
            if [ y = "${q_puppetdb_install?}" ]; then
                q_puppet_enterpriseconsole_install='n'
            fi
        fi

        # Verify that ports 8080 and 8081 are available if this isn't answer-save mode.
        for port in 8080 8081; do
            if ( ! is_save_answers ) && [ 'y' = "${q_puppetdb_install?}" ] && (! is_upgrade ) && tcp_port_in_use localhost $port ; then
                display_newline
                display_failure "Port $port appears to be in use. This port is required for PuppetDB. Please either move the services for this port to another or install on a system with this port available."
            fi
        done

        # If you're not installing master or PuppetDB, you can install console
        if [ ! y = "${q_puppetmaster_install?}" -a ! y = "${q_puppetdb_install?}" ]; then
            display_product 'console' "The console is a web interface where you can view reports, classify nodes, control Puppet runs, and invoke MCollective agents. It can be installed on the puppet master's node, but for performance considerations, especially in larger deployments, it can also be installed on a separate node."
            ask q_puppet_enterpriseconsole_install 'Install the console?' yN
            q_puppetca_install='n'
        fi

        # Verify that port 8140 is available if this isn't answer-save mode.
        if ( ! is_save_answers ) && [ 'y' = "${q_puppetmaster_install?}" -o 'y' = "${q_puppet_enterpriseconsole_install?}" ] && tcp_port_in_use localhost 8140 ; then
            display_newline
            display_failure "Port 8140 appears to be in use. This port is required for the puppet master. Please either move the services for this port to another or install on a system with this port available."
        fi

        # Verify they haven't somehow chosen two out of three roles (such as
        # answer file). This shouldn't actually be possible, since we
        # automatically deselect roles during the interview, but better to be
        # safe than sorry.
        if [ y = "${q_puppetmaster_install?}" -a y = "${q_puppetdb_install?}" -a ! y = "${q_puppet_enterpriseconsole_install?}" ]; then
            display_failure "You may not select the Puppet master and PuppetDB roles together without the console role. Please select either an all-in-one install or a single role."
        fi

        if [ y = "${q_puppetmaster_install?}" -a ! y = "${q_puppetdb_install?}" -a y = "${q_puppet_enterpriseconsole_install?}" ]; then
            display_failure "You may not select the Puppet master and console roles together without the PuppetDB role. Please select either an all-in-one install or a single role."
        fi

        if [ ! y = "${q_puppetmaster_install?}" -a y = "${q_puppetdb_install?}" -a y = "${q_puppet_enterpriseconsole_install?}" ]; then
            display_failure "You may not select the PuppetDB and console roles together without the Puppet master role. Please select either an all-in-one install or a single role."
        fi

        # If we're not installing PuppetDB, we probably need to know where it is.
        if [ ! y = "${q_puppetdb_install?}" ] && [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
            if ! (is_upgrade && is_PE_x_or_greater '3'); then
                ask q_puppetdb_hostname "Hostname for contacting PuppetDB?" String
                ask q_puppetdb_port "Port for contacting PuppetDB?" Port "8081"
            fi
        fi

        if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            :                ${q_puppetmaster_enterpriseconsole_hostname:='localhost'}
        elif [ y = "${q_puppetmaster_install?}" ]; then
            ask q_puppetmaster_enterpriseconsole_hostname "Hostname for contacting the console?" String
            ask q_puppetmaster_enterpriseconsole_port "Port for contacting the console?" Port "443"
        fi

        display_product 'cloud provisioner' 'The cloud provisioner can create and bootstrap new machine instances and add them to your Puppet infrastructure. It should be installed on a trusted node where site administrators have shell access.'
        ask q_puppet_cloud_install 'Install the cloud provisioner?' yN

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" -o y = "${q_puppetdb_install?}" -o y = "${q_puppet_cloud_install?}" ]; then
            q_puppetagent_install='y'
            display_product 'puppet agent' 'The puppet agent role is automatically installed with the console, puppet master, puppetdb, and cloud provisioner roles.'
        else
            display_product 'puppet agent' 'The puppet agent applies configurations from the puppet master and submits reports and inventory information. It should be installed on every node you plan to manage with Puppet.'
            ask q_puppetagent_install 'Install puppet agent?' Yn
        fi

        if [ y = "${q_puppetmaster_install?}" ]; then
            ask q_puppetmaster_certname "The puppet master's certificate will contain a unique name (\"certname\"); this should be the main DNS name at which it can be reliably reached. Puppet master's certname?" StringForceLowerCase "${PLATFORM_HOSTNAME?}" # The master's certname gets used as the filebucket server in site.pp. If it isn't a reachable DNS name, users have to edit site.pp post-install.
            ask q_puppetmaster_dnsaltnames "The puppet master's certificate can contain DNS aliases; agent nodes will only trust the master if they reach it at its certname or one of these official aliases. Puppet master's DNS aliases (comma-separated list)?" StringDNSName "$(display_dnsaltnames "${q_puppetmaster_certname?}" "puppet")"
            display_newline
        fi

        if [ y = "${q_puppetdb_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
            if [ y = "${q_puppetdb_install?}" ]; then
                if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
                    t_main_database_products="The Puppet Enterprise console and PuppetDB"
                    t_main_database_verb="require"
                else
                    t_main_database_products="PuppetDB"
                    t_main_database_verb="requires"
                fi

                echo "${t_main_database_products?} ${t_main_database_verb?} a PostgreSQL database and a user account able to edit it. You can either install PostgreSQL locally or specify a remote database. (which must be configured and available prior to installing the console or PuppetDB)" | display_wrapped_text
            elif [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
                echo "The Puppet Enterprise console requires a PostgreSQL database and a user account able to edit it. This database and a PostgreSQL server are automatically installed and configured, along with PuppetDB, on a node you select for the database support role. You should install this role BEFORE installing the console role. After installing the database support role, you can find auto-generated passwords for the database user and the authentication database user in '/etc/puppetlabs/installer/database_info.install' on that node." | display_wrapped_text
            fi
            display_newline
        fi

        if [ y = "${q_puppetdb_install?}" ]; then
            ask q_database_install "Install a PostgreSQL server locally?" Yn
            # This variable represents whether or not we're using PE postgres,
            # independently of whether it's installed on this node. The main
            # purpose of the variable is to feed into the console install so we
            # know whether to classify the PuppetDB node with manage_database
            # true or false.
            q_pe_database="${q_database_install?}"
        else
            q_database_install='n'
            :           ${q_pe_database:='n'}
        fi

        if [ y = "${q_database_install?}" ]; then

            if ! is_save_answers ; then
                # Make sure the en_US locale with the UTF8 charset is available:
                verify_en_us_utf8
            fi
            if ! is_upgrade && [ -x /opt/puppet/var/lib/pgsql ] ; then
                display_newline
                display " === Existing Puppet Enterprise data detected === "
                display_newline
                display_failure "It looks like Puppet Enterprise had been installed on this machine and it was uninstalled without the purge data option (-d). The existing databases cannot be reused by ths installer. To install Puppet Enterprise on this host, please back up and remove the /opt/puppet/var/lib/pgsql directory, or run the puppet-enterprise-uninstaller with the remove databases (-d) flag."
            fi

            q_database_root_user="pe-postgres"
            # If we're installing both PuppetDB and console, then we can just
            # listen on localhost. Otherwise, console needs to be able to
            # access postgres, so it has to listen on a public port.
            if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
                : ${q_database_host:='localhost'}
            else
                : ${q_database_host:="${PLATFORM_HOSTNAME?}"}
            fi
            q_database_port='5432'
            # Verify that port 5432 is available for the pe-postgresql server
            if ( ! is_save_answers ) && ( ! is_upgrade ) && tcp_port_in_use localhost ${q_database_port} ; then
                display_newline
                display_failure "Port ${q_database_port} appears to be in use. This port is required for the Puppet Enterprise Postgresql Server. Please either move the services for this port to another or install on a system with this port available."
            fi

            q_database_root_password="${q_database_root_password:-"$(gen_password)"}"

            # We're doing setup, so set db variable defaults
            set_database_defaults
          elif [ y = "${q_puppetdb_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ] && !(is_upgrade && is_PE_x_or_greater '3'); then
            # On split PuppetDB/Console installs, default to PuppetDB location
            # as the likely location of postgres. It's either that or they're
            # using their own. On combined or PuppetDB-only installs, we have
            # nothing to reasonably default to.
            if [ y = "${q_puppet_enterpriseconsole_install?}" -a ! y = "${q_puppetdb_install?}" ]; then
                ask q_database_host "What is the hostname of the PostgreSQL server?" String "${q_puppetdb_hostname?}"
            else
                ask q_database_host "What is the hostname of the PostgreSQL server?" String
            fi
            ask q_database_port "What is the port of the PostgreSQL server?" Port "5432"

            if [ y = "${q_puppetdb_install?}" ]; then
                ask q_puppetdb_database_name "What is the name of the PuppetDB database?" String pe-puppetdb
                ask q_puppetdb_database_user "What is the name of the PuppetDB database user?" String pe-puppetdb
                ask q_puppetdb_database_password "What is the password for ${q_puppetdb_database_user?} (the database user)?" Password4
            fi
        fi

        if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            if ! is_upgrade; then
                # We already know the port to use in an upgrade, so we don't want to find a new one or ask.
                if ! is_save_answers; then
                    default_console_port=$(find_unused_tcp_port "localhost" "${CONSOLE_PORT_OPTIONS}")
                    if [ -z "${default_console_port}" ] ; then
                        ask q_puppet_enterpriseconsole_httpd_port "None of the default ports (${CONSOLE_PORT_OPTIONS}) are open for use by the PE console. What is a port for use by the PE console?" Port
                    else
                        q_puppet_enterpriseconsole_httpd_port="${q_puppet_enterpriseconsole_httpd_port:-"${default_console_port}"}"
                    fi
                else
                    ask q_puppet_enterpriseconsole_httpd_port "What is a port for use by the PE console?" Port "443"
                fi

                # In an upgrade, this user already exists, so we don't ask.
                ask q_puppet_enterpriseconsole_auth_user_email "Admin email address (will be used as account name) for accessing the console interface?" Email
                ask q_puppet_enterpriseconsole_auth_password "Password for user ${q_puppet_enterpriseconsole_auth_user_email?} (minimum 8 characters)?" Password8
            fi

            if [ y = "${q_puppetmaster_install}" ]; then
                :                ${q_puppet_enterpriseconsole_master_hostname:="${q_puppetmaster_certname?}"}
                q_puppetmaster_enterpriseconsole_port="${q_puppet_enterpriseconsole_httpd_port?}"
            fi

            # Mail server questions.

            # These answers are set by default but still saved in the answer file.
            # The smtp username and password answers are blank by default but still
            # saved in the answer file to provide the user the template for setting
            # these values manually.
            q_puppet_enterpriseconsole_smtp_use_tls="${q_puppet_enterpriseconsole_smtp_use_tls:-"n"}"
            q_puppet_enterpriseconsole_smtp_port="${q_puppet_enterpriseconsole_smtp_port:-25}"
            q_puppet_enterpriseconsole_smtp_user_auth="${q_puppet_enterpriseconsole_smtp_user_auth:-"n"}"
            q_puppet_enterpriseconsole_smtp_username="${q_puppet_enterpriseconsole_smtp_username:-""}"
            q_puppet_enterpriseconsole_smtp_password="${q_puppet_enterpriseconsole_smtp_password:-""}"

            # On an upgrade, this has already been set, so no need to ask.
            if ! is_upgrade; then
                display_newline
                echo "The console requires an SMTP server to email account information to users." | display_wrapped_text
                display_newline
                ask q_puppet_enterpriseconsole_smtp_host 'What is the name of your SMTP server?' String
            fi

            set_t_path_to_psql

            if ! ( is_upgrade && is_PE_x_or_greater '3') && [ ! y = "${q_database_install?}" ]; then
                ask q_puppet_enterpriseconsole_database_name "What is the name of the console database?" String console
                ask q_puppet_enterpriseconsole_database_user "What is the name of the console database user?" String console
                ask q_puppet_enterpriseconsole_database_password "What is the password for ${q_puppet_enterpriseconsole_database_user?} (the database user)?" Password4

                ask q_puppet_enterpriseconsole_auth_database_name "What is the name of the authentication database?" String console_auth
                while [ "${q_puppet_enterpriseconsole_auth_database_name?}" = "${q_puppet_enterpriseconsole_database_name?}" ]; do
                    unset q_puppet_enterpriseconsole_auth_database_name
                    display "You cannot use the same database for both the console and the authentication database."
                    ask q_puppet_enterpriseconsole_auth_database_name "What is the name of the authentication database?" String console_auth
                done

                ask q_puppet_enterpriseconsole_auth_database_user "What is the name of the authentication database user?" String console_auth
                while [ "${q_puppet_enterpriseconsole_auth_database_user?}" = "${q_puppet_enterpriseconsole_database_user?}" ]; do
                    if [ "${q_puppet_enterpriseconsole_auth_database_user?}" = "${q_puppet_enterpriseconsole_database_user?}" ]; then
                        display "You cannot use the same user as both the console and the authentication database user."
                    fi

                    unset q_puppet_enterpriseconsole_auth_database_user
                    ask q_puppet_enterpriseconsole_auth_database_user "What is the name of the authentication database user?" String console_auth
                done
                ask q_puppet_enterpriseconsole_auth_database_password "What is the password for ${q_puppet_enterpriseconsole_auth_database_user?} (the user authentication database user)?" Password4
            fi

            if ! (is_upgrade && is_PE_x_or_greater '3') && [ ! y = "${q_puppetdb_install?}" ]; then
                display_newline
                echo "In order to properly classify ${q_puppetdb_hostname?} as a PuppetDB server and provide continued management, you must provide the PuppetDB database information." | display_wrapped_text
                display_newline
                ask q_puppetdb_database_name "What is the name of the PuppetDB database?" String pe-puppetdb
                ask q_puppetdb_database_user "What is the name of the PuppetDB database user?" String pe-puppetdb
                ask q_puppetdb_database_password "What is the password for ${q_puppetdb_database_user?} (the database user)?" Password4
            fi

            # If it's a remote postgres and we're not just saving answers, we
            # need to validate that we can connect, and that the
            # databases/users exist. If it's our postgres, we're already going
            # to be ensuring those things, so no need to validate.
            if [ n = "${q_database_install?}" ] && ! is_save_answers; then
                if [ -n "${t_path_to_psql}" ]; then
                    verify_db
                    need_to_verify_db=n
                else
                    need_to_verify_db=y
                fi
            fi
        fi
    else
        display_newline
        if [ "${PLATFORM_NAME}" = "aix" ] ; then
            PLATFORM_DISPLAY_NAME=AIX
        else
            PLATFORM_DISPLAY_NAME=${PLATFORM_NAME}
        fi
        echo "${PLATFORM_DISPLAY_NAME?} ${PLATFORM_RELEASE?} only supports agent installation."
        q_puppetmaster_install='n'
        q_puppet_enterpriseconsole_install='n'
        q_puppetca_install='n'
        q_puppetagent_install='y'
        q_puppet_cloud_install='n'
        q_puppetdb_install='n'
        q_database_install='n'
        q_all_in_one_install='n'

        ask q_puppetagent_server "Puppet master hostname to connect to?" String puppet
        if ( ! is_save_answers ) && [ 'n' = "${q_skip_master_verification:-"n"}" ] ; then
            while ! tcp_port_in_use "${q_puppetagent_server}" 8140 ; do
                query_about_master_connectivity
            done
        fi
        :       ${q_fail_on_unsuccessful_master_lookup:='y'}
    fi

    if [ y = "${q_puppetagent_install?}" ]; then
        t_default_agent_certname="${PLATFORM_HOSTNAME?}"
        # If we're on a master, and the user isn't driving the installer from an answer file
        # set the certname to the master certname provided earlier
        if [ y = "${q_puppetmaster_install?}" ]; then
            # Update the default value to remove visually jarring difference in default/answer.
            t_default_agent_certname="${q_puppetmaster_certname}"
            if [ -z "${q_puppetagent_certname}" ]; then
                q_puppetagent_certname="${q_puppetmaster_certname}"
            fi
            :            ${q_puppetagent_server:="${q_puppetmaster_certname?}"}
        else
            ask q_puppetagent_certname "Puppet agent needs a unique name (\"certname\") for its certificate; this can be an arbitrary string. Certname for this node?" StringForceLowerCase "${t_default_agent_certname}"

            if [ y = "${q_puppet_enterpriseconsole_install?}" -a n = "${q_puppetmaster_install?}" ]; then
                :                ${q_puppet_enterpriseconsole_master_hostname:="${q_puppetagent_server?}"}
            fi
        fi
    fi

    if [ y = "${q_puppetdb_install?}" ]; then
        # We need to know this for classification, and to bind host and port
        :       ${q_puppetdb_hostname:="${q_puppetagent_certname?}"}
        :       ${q_puppetdb_port:='8081'}

        if [ ! y = "${q_puppetmaster_install?}" ] && ! is_upgrade; then
            ask q_puppetmaster_certname "What is the certname of the puppet master?" StringForceLowerCase "${q_puppetagent_server?}"
        fi
    fi

    if [ 'xaix' = "x${PLATFORM_NAME}" -a -x /usr/sbin/updtvpkg ] ; then
        display_product 'updtvpkg' "Puppet Enterprise contains rpm packages that depend on native AIX libraries. In order to resolve these dependencies correctly, the 'updtvpkg' command is used to populate the rpm database with the native AIX libraries already present on the system."
        ask q_run_updtvpkg "Run 'updtvpkg' to populate the rpm database with available native libaries? (this may take some time)" Yn
    else
        q_run_updtvpkg=n
    fi

    #...[ Vendor packages ].................................................

    enqueue_vendor_packages

    # Determine which vendor packages are missing
    t_main_missing_vendor_packages="$(missing_queued_packages)"

    # Continue interview
    if [ ! -z "${ANSWER_FILE_TO_SAVE?}" ]; then
      # When saving answers, always prompt user to install vendor packages
      display_product 'Vendor Packages' "Puppet Enterprise may require additional packages from your operating system vendor. You will need to either install these yourself, or allow them to be automatically installed from your operating system's package repositories."
      if [ ! -z "${t_main_missing_vendor_packages?}" ]; then
        if [ -d `platform_package_dir` ]; then
          display_missing_vendor_packages "${t_main_missing_vendor_packages?}"
        fi
      fi
      ask q_vendor_packages_install 'Allow automatic installation of these packages?' Yn
    elif [ ! -z "${t_main_missing_vendor_packages?}" ]; then
      # When running, only prompt user to install vendor packages if needed
      display_product 'Vendor Packages' "The installer has detected that Puppet Enterprise requires additional packages from your operating system vendor's repositories, and can automatically install them. If you choose not to install these packages automatically, the installer will exit so you can install them manually."
      display_missing_vendor_packages "${t_main_missing_vendor_packages?}"
      ask q_vendor_packages_install 'Install these packages automatically?' Yn
      if [ ! y = "${q_vendor_packages_install?}" ]; then
        display_failure "You must manually install the above packages before installing Puppet Enterprise."
      fi
    else
      # Set default value
      q_vendor_packages_install="${q_vendor_packages_install:-"n"}"
    fi

    #...[ Convenience links ]...............................................

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" ]; then
        display_product 'Convenience Links' "The selected Puppet software will be installed into \"/opt/puppet\", which may not be included in your default shell PATH. For ease of use, this installer can create symbolic links to these executables in \"${PLATFORM_SYMLINK_TARGET?}\"."
        ask q_puppet_symlinks_install "Create symbolic links to Puppet executables in \"${PLATFORM_SYMLINK_TARGET?}\"?" Yn
    else
        q_puppet_symlinks_install=n
    fi

    #...[ Check for existing configuration ]...............................

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdb_install?}" -o y = "q_puppet_enterpriseconsole_install?}" ] && ! is_upgrade ; then
        if [ -x /etc/puppetlabs ] ; then
            display_newline
            display " === Existing Puppet Enterprise configuration detected === "
            display_newline

            display_failure "It looks like Puppet Enterprise had been installed on this machine and it was uninstalled without the purge option (-p). The existing configuration cannot be reused by this installer. To install Puppet Enterprise on this host, please back up any desired configuration files and run the puppet-enterprise-uninstaller with the purge (-p) flag."
        fi
    fi

    #---[ Quit early ]------------------------------------------------------

    if [ ! y = "${q_puppetmaster_install?}" -a ! y = "${q_puppetdb_install?}" -a ! y = "${q_puppetagent_install?}" -a ! y = "${q_puppet_enterpriseconsole_install?}" -a ! y = "${q_puppet_cloud_install?}" ]; then
        display_newline
        display_major_separator
        display_newline
        display_failure "Nothing selected for installation"
    fi

    #---[ Confirm ]---------------------------------------------------------

    display_step 'CONFIRM PLAN'

    render_plan

    #---[ Set OFFER_ROLL_BACK flag ]----------------------------------------------
    # Up until this point, we have made no changes to a system, so a failure
    # prior to this point would not require any sort of roll-back to restore
    # a system to a pristine state. After this point, we may have modified a
    # a system, if only to save an answers file, so we can offer to roll
    # back using the uninstaller
    OFFER_ROLL_BACK='y'

    if is_upgrade; then
        ask q_install 'Perform upgrade?' Yn
    else
        ask q_install 'Perform installation?' Yn
    fi
    if [ ! y = "${q_install?}" ]; then
        display_newline
        display_major_separator
        display_newline
        display "!! Installation cancelled"
        display_newline
        display_major_separator
        do_save_answers
        if is_upgrade && is_PE_x_or_greater '3'; then
          display "Preserving existing database_info"
        else
          save_database_info_etc
        fi
        quit 1
    else
        do_save_answers
        if is_upgrade && is_PE_x_or_greater '3'; then
          display "Preserving existing database_info"
        else
          save_database_info_etc
        fi
    fi

    #---[ Save answers in /etc/puppetlabs ]---------------------------------

    save_answers_etc

    #---[ Ignore q_upgrade_installation=y, #16091 ]------------------------
    ignore_duplicate 'upgrade'

    #---[ Export answers for use with erb ]---------------------------------

    for t_env_variable in `set | ${PLATFORM_EGREP?} '^q_' | sed -n 's/^\(q_[^=][^=]*\).*$/\1/p'`; do export ${t_env_variable}; done
    # Export a non-q variable
    export PLATFORM_HOSTNAME

    # PLATFORM_HOSTNAME_SHORT is used by databases.erb
    export PLATFORM_HOSTNAME_SHORT

    # This is needed for puppet.conf
    export PLATFORM_NAME
    export PLATFORM_PUPPET_GROUP
    export PLATFORM_PUPPET_USER

    #---[ Enqueue our packages ]--------------------------------------------

    # NONPORTABLE
    # Install cloud gems
    if [ y = ${q_puppet_cloud_install?} ]; then
        handle_cloud
    fi

    enqueue_agent_packages

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
        case "${PLATFORM_NAME?}" in
            amazon | centos | rhel | sles)
                enqueue_package 'pe-httpd'
                enqueue_package 'pe-passenger'
                enqueue_package 'pe-mod_ssl'
                enqueue_package 'pe-rubygem-rack'
                enqueue_package 'pe-mcollective-client'
                ;;
            ubuntu | debian)
                enqueue_package 'pe-httpd-mpm-worker'
                enqueue_package 'pe-httpd-common'
                enqueue_package 'pe-httpd'
                enqueue_package 'pe-httpd-bin'
                enqueue_package 'pe-httpd-utils'
                enqueue_package 'pe-passenger'
                enqueue_package 'pe-rubygem-rack'
                enqueue_package 'pe-mcollective-client'
                ;;
            *)
                display_failure "Do not know how to install HTTPD or Puppet master on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # PostgreSQL Packages for PE Console
        enqueue_package 'pe-postgresql'
        # we are installing /opt/puppet/bin/psql at this point
        # override any version we found earlier
        t_path_to_psql='/opt/puppet/bin/psql'
        if [ y = "${q_database_install?}" ]; then
            enqueue_package 'pe-postgresql-server'
        fi
    fi

    if [ y = "${q_puppetmaster_install?}" ]; then
        enqueue_package 'pe-puppet-server'
        # Mcollective Client Packages (and puppetdb)
        enqueue_package 'pe-java'
        enqueue_package 'pe-activemq'
        enqueue_package 'pe-tanukiwrapper'
    fi

    if [ y = "${q_puppetdb_install?}" ]; then
        enqueue_package 'pe-java'

        # PostgreSQL Packages
        enqueue_package 'pe-postgresql'
        # we are installing /opt/puppet/bin/psql at this poing
        # override any previously found version
        t_path_to_psql='/opt/puppet/bin/psql'
        if [ y = "${q_database_install?}" ]; then
            enqueue_package 'pe-postgresql-server'
        fi
    fi

    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # Dashboard Packages
        enqueue_package 'pe-puppet-dashboard'
        enqueue_package 'pe-bundler'

        # Live Management Packages
        enqueue_package 'pe-libevent'
        enqueue_package 'pe-memcached'
        enqueue_package 'pe-live-management'
        # Console packages
        enqueue_package 'pe-console-auth'
        enqueue_package 'pe-console'
        enqueue_package 'pe-certificate-manager'
        enqueue_package 'pe-rubycas-server'
    fi

    #---[ Write out PE version ]-------------------------------------------

    # We need to do this before the puppet agent gets started for the first time
    # to ensure the version gets picked up correctly, so we pick the last time
    # before the packages are installed.

    if ! is_noop; then
        run_suppress_stdout "mkdir -p /opt/puppet && chown ${PLATFORM_ROOT_USER}:${PLATFORM_ROOT_GROUP} /opt/puppet && chmod 755 /opt/puppet"
        run_suppress_stdout "cp ${INSTALLER_DIR}/VERSION /opt/puppet/pe_version && chown ${PLATFORM_ROOT_USER}:${PLATFORM_ROOT_GROUP} /opt/puppet/pe_version && chmod 644 /opt/puppet/pe_version"
    fi

    #---[ Install packages ]------------------------------------------------

    display_step 'INSTALL PACKAGES'

    if [ 'y' = "${q_run_updtvpkg}" ] ; then
        display_comment 'Running /usr/sbin/updtvpkg to update rpm database...'
        run_suppress_output '/usr/sbin/updtvpkg'
    fi

    if is_upgrade && is_console && [ y = "${q_database_transfer?}" ]; then
        t_main_export_dir="${q_database_export_dir?}/puppet-enterprise-database-export"
        run_suppress_stdout "mkdir -p ${t_main_export_dir?}"
        run_suppress_stdout "chown ${PLATFORM_ROOT_USER}:${PLATFORM_ROOT_GROUP} ${t_main_export_dir?}"
        run_suppress_stdout "chmod 700 ${t_main_export_dir?}"

        display_comment "Exporting the console databases to ${t_main_export_dir?}"

        run "/opt/puppet/bin/rake -s -R '${INSTALLER_DIR}' -f /opt/puppet/share/puppet-dashboard/Rakefile db:console:export RAILS_ENV=production DIR=${t_main_export_dir?}"
        # Add the -I entry here so we can load progress_bar
        run "/opt/puppet/bin/rake -s -I /opt/puppet/share/puppet-dashboard/lib -R '${INSTALLER_DIR}' -f /opt/puppet/share/console-auth/Rakefile db:console_auth:export RAILS_ENV=production DIR=${t_main_export_dir?}"
    fi

    if is_upgrade; then
        display_comment 'Upgrading packages'
    fi
    install_queued_packages

    # If we couldn't verify postgres earlier (because it wasn't installed),
    # verify it now.
    if [ y = "${need_to_verify_db:-'n'}" ]; then
        verify_db
    fi

    #---[ Generate "puppet.conf" ]------------------------------------------

    if is_upgrade; then
        # nothing, we want to preserve the existing puppet.conf
        display_comment 'Preserving existing puppet.conf for now...'
    else
        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppet.conf.erb' > '/etc/puppetlabs/puppet/puppet.conf'"
    fi

    #---[ Generate "auth.conf" ]------------------------------------------

    if [ y = "${q_puppetmaster_install?}" ]; then
        if [ -e "/etc/puppetlabs/puppet/auth.conf" ]; then
            # TODO: Possibly warn about /facts here, unless cert manager setup does it
            display_comment 'Preserving existing auth.conf'
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/auth.conf.erb' > '/etc/puppetlabs/puppet/auth.conf'"
        fi
    fi

    #---[ Lay down "autosign.conf" if master w/o console ] -----------------

    if [ y = ${q_puppetmaster_install?} -a n = ${q_puppet_enterpriseconsole_install?} ]; then
        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/autosign.conf.erb' >> '/etc/puppetlabs/puppet/autosign.conf'"
    fi

    #---[ Extend "autosign.conf" if master with remote puppetdb ] -----------------

    if [ y = ${q_puppetmaster_install?} -a n = ${q_puppetdb_install?} ]; then
        run "echo ${q_puppetdb_hostname?} >> '/etc/puppetlabs/puppet/autosign.conf'"
    fi

    #---[ Setup packages ]--------------------------------------------------

    if [ y = "${q_puppetmaster_install?}" ]; then
        display_comment 'Setting up puppet master...'

        # FIXME PACKAGING should packages create these directories and set ownership?
        run_suppress_stdout "mkdir -p /var/opt/lib/pe-puppetmaster/public/ /var/opt/lib/pe-puppetmaster/public/tmp ${PLATFORM_PUPPET_HOME?}"
        run_suppress_stdout "chown -R ${PLATFORM_PUPPET_USER}:${PLATFORM_PUPPET_GROUP} ${PLATFORM_PUPPET_HOME?} /var/log/pe-puppet/"

        if [ -s '/etc/puppetlabs/httpd/conf.d/puppetmaster.conf' ] && ! ${PLATFORM_EGREP?} -q 'VirtualHost \*:8140' '/etc/puppetlabs/httpd/conf.d/puppetmaster.conf'; then
            # We don't put this in conf.d, otherwise apache will try to load it and fail.
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppetmaster.conf.erb' > '/etc/puppetlabs/httpd/puppetmaster.conf.new'"

            #display_comment "Preserving existing /etc/puppetlabs/httpd/conf.d/puppetmaster.conf; please manually incorporate changes from /etc/puppetlabs/httpd/conf.d/puppetmaster.conf.new"
            t_warn_about_puppetmaster_conf='y'
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppetmaster.conf.erb' > '/etc/puppetlabs/httpd/conf.d/puppetmaster.conf'"
        fi

        # Generate the master's SSL server certificate
        if [ ! -e $(/opt/puppet/bin/puppet master --configprint hostcert) ]; then
            run_suppress_stdout "/opt/puppet/bin/puppet cert --generate ${q_puppetmaster_certname?} --dns_alt_names '${q_puppetmaster_dnsaltnames?}' --verbose --color=false|| true"
        fi

        # This is done to make sure that apache drops any X-Forwarded-For headers
        # before passing them on to rack and passenger.

        filebuffer_append "RequestHeader unset X-Forwarded-For"
        filebuffer_write "/etc/puppetlabs/httpd/conf.d/headers.conf"

        run "mkdir -p '/etc/puppetlabs/puppet-dashboard'"
        if [ ! -e "/etc/puppetlabs/puppet-dashboard/external_node" ]; then
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/external_node.erb' > '/etc/puppetlabs/puppet-dashboard/external_node'"
        fi

        run_suppress_stdout 'chmod a+rx /etc/puppetlabs/puppet-dashboard/external_node'
        run_suppress_stdout 'chmod a+rX /etc/puppetlabs/puppet-dashboard'

        if [ ! -e '/etc/puppetlabs/puppet/manifests/site.pp' ]; then
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/site.pp.erb' > '/etc/puppetlabs/puppet/manifests/site.pp'"
        fi

        # This is done to make it possible to trigger a license
        # check during master startup from config.ru, invoked by Passenger, in the
        # PE environment. To be removed when we insert a hook in Puppet to enable
        # this more cleanly.
        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/config.ru.erb' > '/var/opt/lib/pe-puppetmaster/config.ru'"

        # These files are not used by PE anymore, they can be safely removed
        for file in send_cert_request.rb receive_signed_cert.rb; do
            if [ -f "/opt/puppet/bin/${file}" ]; then
                run_suppress_stdout "rm -f /opt/puppet/bin/${file}"
            fi
        done

        # FIXME PACKAGING Should the packages set the permissions correctly?
        run_suppress_stdout 'chown -R ${PLATFORM_PUPPET_USER}:${PLATFORM_PUPPET_GROUP} ${PLATFORM_PUPPET_HOME?} /var/opt/lib/pe-puppetmaster/ /var/log/pe-puppet/'

        # XXX Temporarily work around bug in debian packaging.
        run "rm -f /etc/puppetlabs/httpd/mods-enabled/pe-httpd-passenger.*"
    elif [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # TODO Properly uninstall fake master
        run "rm -f /etc/puppetlabs/httpd/conf.d/puppetmaster.conf"
    fi

    display_comment 'Checking the agent certificate name detection...'
    if run_suppress_stdout "/opt/puppet/bin/puppet agent --configprint certname --color=false"; then
        if [ ! y = "${q_puppetmaster_install?}" ] && [ y = "${q_puppet_enterpriseconsole_install?}" -o y = "${q_puppetdb_install?}" -o y = "${q_puppet_agent_first_run:-"y"}" ] ; then
          display_comment 'Setting up puppet agent...'
          run_suppress_stdout "/opt/puppet/bin/puppet agent --test --color=false || true"
        fi
    else
        display_failure 'The agent certificate name was incorrect; please check that your system can correctly resolve its own FQDN in DNS.'
    fi

    # If this is a master or console or puppetdb install, ignore the q_puppet_agent_first_run value
    if [ y = "${q_puppetmaster_install?}" ] || [ y = "${q_puppet_enterpriseconsole_install?}" ] || [ y = "${q_puppetdb_install?}" ] || [ y = "${q_puppet_agent_first_run:-"y"}" ] ; then
        # NONPORTABLE
        case "${PLATFORM_NAME?}" in
            amazon | centos | rhel | sles | aix)
                bounce_service 'pe-puppet'
                enable_service 'pe-puppet'
                ;;
            ubuntu | debian)
                run "printf \"START=true\nDAEMON_OPTS=''\n\" > /etc/default/pe-puppet"
                bounce_service 'pe-puppet'
                enable_service 'pe-puppet'
                ;;
            solaris)
                if [ ! -d /etc/puppetlabs ]; then
                    run_suppress_stdout "mkdir /etc/puppetlabs"
                    run_suppress_stdout "chown ${PLATFORM_ROOT_USER}:${PLATFORM_ROOT_GROUP} /etc/puppetlabs"
                    run_suppress_stdout "chmod 755 /etc/puppetlabs"
                fi
                run_suppress_stdout "/usr/sbin/svccfg import /var/svc/manifest/network/pe-puppet.xml"
                run_suppress_stdout "/usr/sbin/svcadm enable svc:/network/pe-puppet:default"
                ;;
            *)
                display_failure "Do not know how to start puppet agent service on this platform"
                ;;
        esac
    fi

    # All of these roles need local copies of the modules
    if [ y = "${q_puppetmaster_install?}" ] || [ y = "${q_puppet_enterpriseconsole_install?}" ] || [ y = "${q_puppetdb_install?}" ]; then
        install_puppet_modules
        # We just installed a bunch of modules, or upgraded them, which means
        # we may have swapped out a bunch of parser functions that had
        # already be loaded by pe-puppet (I'm looking at you, pe_accounts and
        # create_resource). Bouncing the service will ensure that those parser
        # functions will be reloaded. And then we need to pluginsync the new
        # versions of the modules.
        if is_upgrade; then
          run_suppress_stdout "/opt/puppet/bin/puppet apply --exec \"Ini_setting { ensure => present, path => '/etc/puppetlabs/puppet/puppet.conf', section => main }\
          ini_setting { 'server': setting => server, value => '${q_puppetagent_server?}' }\
          ini_setting { 'certname': setting => certname, value => '${q_puppetagent_certname?}' }\""

          if [ y = "${q_puppetmaster_install?}" ]; then
              bounce_service 'pe-httpd'
              wait_for_passenger 'upgrade'
          fi
          bounce_service 'pe-puppet'

          run_suppress_stdout "/opt/puppet/bin/puppet plugin download"
        fi
    fi
    if is_upgrade; then
        if [ y = "${q_puppetmaster_install?}" ]; then
          display_comment 'Updating puppet.conf report processors'
          run_suppress_stdout "/opt/puppet/bin/puppet resource ini_subsetting /etc/puppetlabs/puppet/puppet.conf path=/etc/puppetlabs/puppet/puppet.conf section=master setting=reports subsetting=https subsetting_separator=, ensure=absent"
          run_suppress_stdout "/opt/puppet/bin/puppet resource ini_subsetting /etc/puppetlabs/puppet/puppet.conf path=/etc/puppetlabs/puppet/puppet.conf section=master setting=reports subsetting=http subsetting_separator=, ensure=present"
        fi
    fi

    if [ y = "${q_database_install?}" ]; then
        display_comment 'Setting up the database...'

        # Verify that we can set the password here.
        configure_postgresql_server

        # Set tablespace names & locations for use with the following erb
        t_console_tablespace='pe-console'
        t_console_tablespace_location='/opt/puppet/var/lib/pgsql/9.2/console'
        t_puppetdb_tablespace='pe-puppetdb'
        t_puppetdb_tablespace_location='/opt/puppet/var/lib/pgsql/9.2/puppetdb'

        export t_console_tablespace
        export t_console_tablespace_location
        export t_puppetdb_tablespace
        export t_puppetdb_tablespace_location

        # Create tablespace folders
        create_tablespace_folder ${t_console_tablespace_location?} "pe-postgres" "pe-postgres"
        create_tablespace_folder ${t_puppetdb_tablespace_location?} "pe-postgres" "pe-postgres"

        # Postgres will be restarted when we configure it, so make sure to wait
        # until it's running. Unless we're running noop, in which case it's not
        # installed so we can't wait for it.
        if ! is_noop && ! wait_for_db 20; then
            display_failure "The PostgreSQL server failed to start; unable to proceed"
        fi

        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/databases.erb' | su - ${q_database_root_user} -c ${t_path_to_psql?} -s /bin/bash"

        # Now we've created databases and users, so if we roll back, we should run it with the -d flag
        ROLL_BACK_DBS='y'
    fi

    # If this is a fresh db install we should be setting the password to the desired password. If we are just setting the db up we
    # have already verified the credentials so we should be able to just set up the dbs.
    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        display_comment 'Setting up the console...'
        if !(is_upgrade && is_PE_x_or_greater '3'); then
            #...[ database.yml ]....................................................

            backup_file '/etc/puppetlabs/puppet-dashboard/database.yml'
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/database.yml.erb' > '/etc/puppetlabs/puppet-dashboard/database.yml'"
        fi

        #...[ settings.yml ]....................................................

        # Generate the session key for settings.yml
        t_session_key_dashboard=`dd if=/dev/urandom bs=4k count=512 2> /dev/null | sha512sum  | $PLATFORM_AWK '{print $1}'`
        export t_session_key_dashboard

        if [ -s '/etc/puppetlabs/puppet-dashboard/settings.yml' ]; then
            backup_file '/etc/puppetlabs/puppet-dashboard/settings.yml'
            # Remove the old fake master settings
            run "sed -i -e 's/inventory_server:.*/inventory_server: ${q_puppet_enterpriseconsole_master_hostname?}/' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            run "sed -i -e 's/inventory_port:.*/inventory_port: 8140/' '/etc/puppetlabs/puppet-dashboard/settings.yml'"

            # Add new settings if they don't exist
            if ! ${PLATFORM_EGREP?} -q 'secret_token:' '/etc/puppetlabs/puppet-dashboard/settings.yml'; then
                run "sed -i -e '\$i\\secret_token: ${t_session_key_dashboard?}' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            fi

            if ! ${PLATFORM_EGREP?} -q 'nodes_per_page:' '/etc/puppetlabs/puppet-dashboard/settings.yml'; then
                run "sed -i -e '\$i\\nodes_per_page: 20' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            fi
            if ! ${PLATFORM_EGREP?} -q 'classes_per_page:' '/etc/puppetlabs/puppet-dashboard/settings.yml'; then
                run "sed -i -e '\$i\\classes_per_page: 50' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            fi
            if ! ${PLATFORM_EGREP?} -q 'groups_per_page:' '/etc/puppetlabs/puppet-dashboard/settings.yml'; then
                run "sed -i -e '\$i\\groups_per_page: 50' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            fi
            if ! ${PLATFORM_EGREP?} -q 'reports_per_page:' '/etc/puppetlabs/puppet-dashboard/settings.yml'; then
                run "sed -i -e '\$i\\reports_per_page: 20' '/etc/puppetlabs/puppet-dashboard/settings.yml'"
            fi
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/settings.yml.erb' > '/etc/puppetlabs/puppet-dashboard/settings.yml'"
        fi

        if !(is_upgrade && is_PE_x_or_greater '3'); then
            # Generate the session key for cas_client_config.yml
            t_session_key_cas=`dd if=/dev/urandom bs=4k count=512 2> /dev/null | sha512sum  | $PLATFORM_AWK '{print $1}'`
            export t_session_key_cas

            backup_file '/etc/puppetlabs/console-auth/database.yml'
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/console_auth_db_config.yml.erb' > '/etc/puppetlabs/console-auth/database.yml'"
        fi

        #TODO these ownership and permission fixes should also be put in the packages for console-auth
        run "chmod 440 /etc/puppetlabs/console-auth/database.yml"
        run "chown pe-auth:puppet-dashboard /etc/puppetlabs/console-auth/database.yml"

        q_public_hostname="${PLATFORM_HOSTNAME?}"

        # Get EC2 public-hostname for '/etc/puppetlabs/console-auth/config.yml' and '/etc/puppetlabs/rubycas-server/config.yml'
        if [ ! -z `/opt/puppet/bin/facter ec2_instance_id` ]; then
            #  169.254.169.254 is used in Amazon EC2 to distribute metadata to cloud instances
            q_public_hostname=`curl -s http://169.254.169.254/latest/meta-data/public-hostname`
        fi

        export q_public_hostname


        # If the console auth configuration exists, back it up and then edit it.
        if [ -s '/etc/puppetlabs/console-auth/config.yml' ]; then
            backup_file '/etc/puppetlabs/console-auth/config.yml'

            # Unconditionally delete the console_hostname key/value (PE = 3.0).
            run "sed -i -e '/console_hostname:.*/d' '/etc/puppetlabs/console-auth/config.yml'"

            # If the configuration doesn't have a console_absolute_url key/value, add one with the absolute URL to the console (PE >= 3.0.1).
            if ! ${PLATFORM_EGREP?} -q 'console_absolute_url:' '/etc/puppetlabs/console-auth/config.yml'; then
                run "sed -i -e '/authentication:/a\\  console_absolute_url: https://${q_public_hostname?}:${q_puppet_enterpriseconsole_httpd_port?}' '/etc/puppetlabs/console-auth/config.yml'"
            fi

            # If the configuration has a cas_url key/value, so we need to ensure it's a relative URL (PE >= 2.5.x).
            # This was only an absolute URL in PE 3.0.
            if ${PLATFORM_EGREP?} -q 'cas_url:' '/etc/puppetlabs/console-auth/config.yml'; then
                run "sed -i -e 's/cas_url:.*/cas_url: \\/cas/' '/etc/puppetlabs/console-auth/config.yml'"

            # The configuration doesn't contain a cas_url key/value, let's add one with the proper relative URL.
            else
                run "sed -i -e '/authentication:/a\\  cas_url: /cas' '/etc/puppetlabs/console-auth/config.yml'"
            fi

            # If the configuration doesn't have a service_url key/value, add one with the relative URL to the console (PE >= 3.0.1).
            if ! ${PLATFORM_EGREP?} -q 'service_url:' '/etc/puppetlabs/console-auth/config.yml'; then
                run "sed -i -e '/authentication:/a\\  service_url: /' '/etc/puppetlabs/console-auth/config.yml'"
            fi

            # If the configuration doesn't have a validate_url key/value, add one with the absolute URL to RubyCAS's endpoint on localhost (PE >= 3.0.1).
            if ! ${PLATFORM_EGREP?} -q 'validate_url:' '/etc/puppetlabs/console-auth/config.yml'; then
                run "sed -i -e '/authentication:/a\\  validate_url: https://localhost:${q_puppet_enterpriseconsole_httpd_port}/cas/proxyValidate' '/etc/puppetlabs/console-auth/config.yml'"
            fi

        # Otherwise just use the template.
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/console_auth_config.yml.erb' > '/etc/puppetlabs/console-auth/config.yml'"
        fi

        if ! ${PLATFORM_EGREP?} -q 'log:' '/etc/puppetlabs/console-auth/config.yml'; then
            run "cat '${INSTALLER_DIR}/erb/console_auth_log_config.yml' >> '/etc/puppetlabs/console-auth/config.yml'"
        fi


        run "chmod 640 /etc/puppetlabs/console-auth/config.yml"
        run "chown pe-auth:puppet-dashboard /etc/puppetlabs/console-auth/config.yml"

        if (is_upgrade && is_PE_x_or_greater '3'); then
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/read_console_auth_db_config.erb' > '/etc/puppetlabs/rubycas-server/db_config.tmp'"
            . '/etc/puppetlabs/rubycas-server/db_config.tmp'
            export q_puppet_enterpriseconsole_auth_database_name q_puppet_enterpriseconsole_auth_database_user q_puppet_enterpriseconsole_auth_database_password
            export q_database_host q_database_port
            run_suppress_output "rm -f /etc/puppetlabs/rubycas-server/db_config.tmp"
        fi

        # The install package lays down an empty config.yml, so we need to make sure it's not zero size too
        if [ -s '/etc/puppetlabs/rubycas-server/config.yml' ]; then
            backup_file '/etc/puppetlabs/rubycas-server/config.yml'
            # Our erb template reads this file, so we have to write to a tmp or
            # we'll blow it away before reading.
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/rewrite_rubycas_config.yml.erb' > '/etc/puppetlabs/rubycas-server/config.yml.tmp'"
            run "mv '/etc/puppetlabs/rubycas-server/config.yml.tmp' '/etc/puppetlabs/rubycas-server/config.yml'"
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/rubycas_config.yml.erb' > '/etc/puppetlabs/rubycas-server/config.yml'"
        fi

        run "chmod 600 /etc/puppetlabs/rubycas-server/config.yml"
        run "chown pe-auth:pe-auth /etc/puppetlabs/rubycas-server/config.yml"

        # If the file exists, we want to make sure it doesn't have the old
        # cas_host and cas_port settings, but otherwise leave it alone because
        # it can be modified by users to add new authorization sources, and
        # also it contains the session_secret.
        if [ -e '/etc/puppetlabs/console-auth/cas_client_config.yml' ]; then
            backup_file '/etc/puppetlabs/console-auth/cas_client_config.yml'
            run "sed -i -e '/cas_port:.*/d' -e '/cas_host:.*/d' /etc/puppetlabs/console-auth/cas_client_config.yml"
            if ! ${PLATFORM_EGREP?} -q '^[^#]*session_timeout:' '/etc/puppetlabs/console-auth/cas_client_config.yml'; then
              run "sed -i -e '/authentication:/a\\  session_timeout: 1200' '/etc/puppetlabs/console-auth/cas_client_config.yml'"
            fi
        else
            run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/cas_client_config.yml.erb' > '/etc/puppetlabs/console-auth/cas_client_config.yml'"
            run "chmod 640 '/etc/puppetlabs/console-auth/cas_client_config.yml'"
            run "chown pe-auth:puppet-dashboard /etc/puppetlabs/console-auth/cas_client_config.yml"
        fi

        # setup logging for console-auth
        run "mkdir -p /var/log/pe-console-auth"
        run "touch /var/log/pe-console-auth/cas.log"
        run "touch /var/log/pe-console-auth/auth.log"
        run "chmod 770 /var/log/pe-console-auth"
        run "chmod 660 /var/log/pe-console-auth/auth.log"
        run "touch /var/log/pe-console-auth/cas_client.log"
        run "chmod 660 /var/log/pe-console-auth/cas_client.log"
        run "chown -R pe-auth:puppet-dashboard /var/log/pe-console-auth"

        # Ensure Ownership is correct for all the config.ru files
        run "chown puppet-dashboard:puppet-dashboard /opt/puppet/share/live-management/config.ru"
        run "chown pe-auth:pe-auth /opt/puppet/share/console-auth/config.ru"
        run "chown pe-auth:pe-auth /opt/puppet/share/rubycas-server/config.ru"

        if [ y = "${q_puppetmaster_install?}" ]; then
            # only start the http service if we are a CA
            # and can generate signed certs as a part of installation
            bounce_service 'pe-httpd'
            run_suppress_stdout "chown ${PLATFORM_ROOT_USER}:${PLATFORM_ROOT_GROUP} ${PLATFORM_PUPPET_HOME?}/lib"
            # Enabled the second time pe-httpd is bounced
        fi

        if [ ! -e '/opt/puppet/share/puppet-dashboard/certs/pe-internal-dashboard.private_key.pem' ]; then
            console_rake_task 'cert:create_key_pair'
        fi

        if [ y = "${q_puppetmaster_install?}" ]; then
            wait_for_passenger install
        fi

        if [ ! -e '/opt/puppet/share/puppet-dashboard/certs/pe-internal-dashboard.cert.pem' ]; then
            # There's no way to tell whether or not we've already done a
            # cert request, but if we have it's harmless to try again. The
            # rake task will fail, however, so we just ignore the failure
            # and move on.
            console_rake_task 'cert:request' || :

            # We autosign the Console certificates when console/master are split. Otherwise we need to sign it now.
            if [ y = "${q_puppetmaster_install?}" ]; then
                run_suppress_stdout '/opt/puppet/bin/puppet cert --sign pe-internal-dashboard --color=false' || :
            fi

            console_rake_task 'cert:retrieve'
        fi

        run_suppress_stdout 'chown -Rvf puppet-dashboard:puppet-dashboard /opt/puppet/share/puppet-dashboard/certs'

        run "/opt/puppet/bin/erb -T - '${INSTALLER_DIR}/erb/puppetdashboard.conf.erb' > '/etc/puppetlabs/httpd/conf.d/puppetdashboard.conf'"

        if [ y = "${q_database_install?}" ]; then
            console_rake_task 'db:create'
        fi

        display "Performing Puppet dashboard database migration. This may take some time for larger databases..."
        display_newline
        console_rake_task 'db:migrate'

        run_suppress_stdout 'chown -Rvf puppet-dashboard:puppet-dashboard /var/log/pe-puppet-dashboard/*'
        # migrate console-auth schema
        display "Performing Puppet console authentication database migration. This may take some time for larger databases..."
        display_newline
        console_auth_rake_task 'db:migrate'

        if is_upgrade && is_console && [ y = "${q_database_transfer?}" ]; then
            display_comment "Importing the console databases from ${t_main_export_dir?}"

            # the cron job will add group/classes/etc and give us a very sad time, so we need to disable it first
            run "sed -i s/^/#/g /etc/cron.d/default-add-all-nodes"

            verbose_bundle_exec "/opt/puppet/bin/rake -s -R '${INSTALLER_DIR}' -f /opt/puppet/share/puppet-dashboard/Rakefile db:console:import RAILS_ENV=production DIR=${t_main_export_dir?}"
            # Add the -I entry here so we can load progress_bar
            verbose_bundle_exec "/opt/puppet/bin/rake -s -I /opt/puppet/share/puppet-dashboard/lib -R '${INSTALLER_DIR}' -f /opt/puppet/share/console-auth/Rakefile db:console_auth:import RAILS_ENV=production DIR=${t_main_export_dir?}"

            run "sed -i s/^#//g /etc/cron.d/default-add-all-nodes"
        fi

        if ! is_upgrade; then
            console_auth_rake_task "db:create_user USERNAME='${q_puppet_enterpriseconsole_auth_user_email}' PASSWORD='${q_puppet_enterpriseconsole_auth_password}' ROLE='admin'"
        fi
    fi


    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # TODO Don't overwrite this
        generate_global_passenger_conf
    fi

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
        # Make the display text more specific.
        if [ y = "${q_puppetmaster_install?}" -a y = "${q_puppet_enterpriseconsole_install?}" ]; then
            http_for_string='puppet master and console'
        elif [ y = "${q_puppetmaster_install?}" ]; then
            http_for_string='puppet master'
        elif [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            http_for_string='puppet console'
        fi

        display_comment "Starting http server for ${http_for_string}."

        # NONPORTABLE
        case "${PLATFORM_NAME?}" in
            ubuntu | debian)
                # Ubuntu's "pe-httpd" can't cope with ".bak" files.
                run_suppress_stdout "rm -rf /etc/puppetlabs/httpd/*/*.bak"
                # Ubuntu's "pe-httpd" doesn't enable some important modules by default
                run_suppress_stdout "/opt/puppet/sbin/a2enmod ssl headers authnz_ldap ldap"
                # Need to munge the /etc/default/pe-puppet-dashboard-workers init file for sanity
                [ -f '/etc/default/pe-puppet-dashboard-workers' ] && run_suppress_stdout "sed -i 's/### START=no/START=yes/g' /etc/default/pe-puppet-dashboard-workers"
                ;;
        esac

        if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            bounce_service 'pe-memcached'
            enable_service 'pe-memcached'
        fi

        if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppet_enterpriseconsole_install?}" ]; then
            # Start the http service if we are a CA
            # and can generate signed certs as a part of installation
            # or if we're an enterprise console with our certs automatically signed.
            bounce_service 'pe-httpd'
            enable_service 'pe-httpd'
        fi

        if [ y = "${q_puppetmaster_install?}" ]; then
            # Pluginsync modules down so facts are immediately available
            run_suppress_stdout "/opt/puppet/bin/puppet plugin download"
            configure_certificate_manager
        fi

        if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
            run_suppress_stdout 'touch /var/log/pe-puppet-dashboard/certificate_manager.log'
            run_suppress_stdout 'chown -Rvf puppet-dashboard:puppet-dashboard /var/log/pe-puppet-dashboard/*'
            bounce_service 'pe-puppet-dashboard-workers'
            enable_service 'pe-puppet-dashboard-workers'

            # Create default group, add correct classes to it
            console_rake_task 'defaultgroup:ensure_default_group'
        fi
    fi

    install_utils_to_bin
    if [ y = "${q_puppet_symlinks_install?}" ]; then
        display_comment "Creating symbolic links in \"${PLATFORM_SYMLINK_TARGET?}\"..."
        install_symlink bin/facter bin/puppet bin/pe-man bin/hiera
        # mcollective-client is bound to the puppetmaster install for now
        if [ y = "${q_puppetmaster_install}" -o y = "${q_puppet_enterpriseconsole_install}" ]; then
            install_symlink bin/mco
        fi
    fi

    # Configure MCollective (Mainly to generate RSA keys)
    if [ y = "${q_puppetmaster_install?}" ]; then
        configure_mcollective_master
    fi

    # On the PuppetDB node, this will configure PuppetDB itself. On a master or
    # console, it will configure the terminus, etc.
    if [ y = "${q_puppetdb_install?}" -o y = "${q_puppetmaster_install?}" ]; then
        configure_puppetdb
    fi

    if [ y = "${q_puppet_enterpriseconsole_install?}" ]; then
        classify_mcollective_roles
        if !(is_upgrade && is_PE_x_or_greater '3'); then
            # On a fresh install or upgrade from 2.8, we classify PuppetDB
            configure_puppetdb_master_classes
            configure_puppetdb_classes
        else
            # This will find all 'database_password' parameters on node
            # class memberships, filter for those on class 'pe_puppetdb',
            # and then destroy them.
            console_rails_run "Parameter.find_all_by_key_and_parameterable_type('database_password', 'NodeClassMembership', :include => {:parameterable => :node_class}).select {|p| p.parameterable.node_class.name == 'pe_puppetdb'}.each(&:destroy)"
        fi

        # Postgres could be restarted again after configuring PuppetDB, so we
        # wait for it to come back up before proceeding to run rake tasks which
        # modify the DB. If we're not noop.
        if ! is_noop && ! wait_for_db 20; then
            display_failure "The PostgreSQL server failed to start; unable to proceed"
        fi

        display 'Applying enqueued configurations...'
        console_rake_task_run_registered
        display 'All configurations were successfully applied!'
    fi

    #---[ Finish installation ]---------------------------------------------
    cron_enable
    run "/opt/puppet/bin/facter --puppet --yaml > /etc/puppetlabs/mcollective/facts.yaml"
    run "chown ${PLATFORM_PUPPET_USER}:${PLATFORM_PUPPET_GROUP} /etc/puppetlabs/puppet/puppet.conf"
    run "chmod 600 /etc/puppetlabs/puppet/puppet.conf"

    # When we install the console, we need to kick the puppet agent so that
    # this node gets added to the console.
    if [ y = "${q_puppet_enterpriseconsole_install}" ]; then
        bounce_service 'pe-puppet'
    fi

    display_step 'DONE'
    if is_upgrade; then
        display 'Thanks for upgrading Puppet Enterprise!'
    else
        display 'Thanks for installing Puppet Enterprise!'
        echo 'Puppet Enterprise has been installed to "/opt/puppet," and its configuration files are located in "/etc/puppetlabs".' | display_wrapped_text
    fi

    display_newline

    if [ ! -z "${ANSWER_FILE_TO_SAVE?}" ]; then
        display_comment "Answers from this session saved to '${ANSWER_FILE_TO_SAVE?}'"
        if [ "y" = "${q_database_install}" ] ; then
            display_comment 'In addition, auto-generated database users and passwords have been saved to "/etc/puppetlabs/installer/database_info.install"'
            echo "!!! WARNING: Do not discard these files! All auto-generated database users and passwords have been saved in them. You will need this information to configure the console role during installation." | display_wrapped_text
        fi
    else
        display_newline
        echo "!!! WARNING: An answer file could not be saved so, to prevent data loss, supplied and auto-generated database users' passwords have been saved to '/etc/puppetlabs/installer/database_info.install'. This file should be secured as soon as possible!" | display_wrapped_text
    fi

    display_newline
    display_major_separator
    display_newline

    if [ y = "${q_puppet_enterpriseconsole_install}" ]; then
        CONSOLE_URL="https://${PLATFORM_HOSTNAME?}:${q_puppet_enterpriseconsole_httpd_port?}"
        if [ '443' = "${q_puppet_enterpriseconsole_httpd_port?}" ]; then
          CONSOLE_URL="https://${PLATFORM_HOSTNAME?}"
        fi
        display "The console can be reached at the following URI:\n *  ${CONSOLE_URL?}"
        display_newline
    fi

    # XXX Don't warn about ports for now. Too lazy to do anything about the console port.
    if ! is_upgrade; then
        warn_open_ports
    fi

    warn_on_low_memory

    # Clean up the stuff we exported
    unset PLATFORM_HOSTNAME
    # Get rid of the development.log
    run "rm -f /var/log/pe-puppet-dashboard/development.log"

    quit
fi

#===[ End ]=============================================================

# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab
